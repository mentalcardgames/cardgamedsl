# Seeds for failure cases proptest has generated in the past. It is
# automatically read and these particular cases re-run before any
# novel cases are generated.
#
# It is recommended to check this file in to source control so that
# everyone who runs the test benefits from these saved cases.
cc 22e60919cd334ebff74dcb1785097066dd9fd7c27474b1a4b4283a05a9b1bae2 # shrinks to expr = Game { flows: [] }
cc 11caf8307cba7f981eac24d109e2c803e74c244f3c6e9cc3a7163b06fcea64c0 # shrinks to expr = Game { flows: [Conditional(Conditional { cases: [Bool(Aggregate(OutOfPlayer(Player(Aggregate(OwnerOfCardPostion(Query(Bottom(""))))), Stage(""))), [Stage(SeqStage { stage: "", player: Query(Turnorder(Aggregate(ExtremaIntCollection(Max, IntCollection { ints: [] })))), end_condition: UntilEnd, flows: [] })]), Bool(Unary(Not, Unary(Not, Aggregate(Compare(Int(Literal(0), Eq, Literal(0)))))), [])] })] }
cc 4c295c67eefad96fd48eb20406ed04baa11c93bff2d7043f192a75c5261d8b92 # shrinks to expr = Action { action: BidAction { quantitiy: Int { int: Aggregate { aggregate: SumOfCardSet { card_set: Group { group: NotCombo { combo: "IdentTest", groupable: LocationCollection { location_collection: LocationCollection { locations: ["S"] } } } }, pointmap: "IdentTest" } } } } }
cc 7a81948f2d52b4857cb669aeda5c7ec87bbc0d53994965031e8723a5cbc8d5f2 # shrinks to expr = Action { action: BidAction { quantitiy: IntRange { int_range: IntRange { start: (Eq, Literal { int: 1 }), op_int: [(And, Eq, Literal { int: 1 })] } } } }
cc 125e20186dd7733592b928b260448a868a02505080651e547ccec45c1b82f5df # shrinks to expr = SetUp { setup: CreateLocation { locations: [""], owner: Player { player: Literal { name: "P1" } } } }
cc 6a3c21704162e691dab339b67d9f88150517f9371e5af67e4d5a2bc23c872511 # shrinks to expr = Action { action: PlayerOutOfStageAction { players: PlayerCollection { player_collection: Literal { players: [Aggregate { aggregate: OwnerOfCardPostion { card_position: Query { query: At { location: "IdentTest", int_expr: Binary { int: Runtime { runtime: PlayRoundCounter }, op: Div, int1: Binary { int: Aggregate { aggregate: SumOfIntCollection { int_collection: IntCollection { ints: [Runtime { runtime: PlayRoundCounter }] } } }, op: Minus, int1: Query { query: IntCollectionAt { int_collection: IntCollection { ints: [Binary { int: Literal { int: 697424827 }, op: Minus, int1: Query { query: IntCollectionAt { int_collection: IntCollection { ints: [Runtime { runtime: StageRoundCounter }, Binary { int: Binary { int: Query { query: IntCollectionAt { int_collection: IntCollection { ints: [Binary { int: Runtime { runtime: PlayRoundCounter }, op: Minus, int1: Runtime { runtime: PlayRoundCounter } }] }, int_expr: Literal { int: 1853701751 } } }, op: Minus, int1: Runtime { runtime: PlayRoundCounter } }, op: Plus, int1: Aggregate { aggregate: SumOfCardSet { card_set: Group { group: Where { groupable: Location { name: "IdentTest" }, filter: Aggregate { aggregate: Combo { combo: "BASE_CASE" } } } }, pointmap: "IdentTest" } } }] }, int_expr: Literal { int: 1 } } } }, Literal { int: 1 }] }, int_expr: Literal { int: 1 } } } } } } } } }, Literal { name: "P1" }] } } } }
cc a97a50bdc328fe69e8e10732f90b4b9b96391089415825f3641fee4786394434 # shrinks to expr = Action { action: EndAction { end_type: Turn } }
cc ac3fda110d644df489b08414917d25297d994956ae510fcdcf83ac9f69cd566f # shrinks to expr = SetUp { setup: CreateCardOnLocation { location: "IdentTest", types: Types { types: [("upa", ["a"])] } } }
cc f8b9a5418f5c2d3568c8979ffde21368710276b75a863ce86549d8044ec01a20 # shrinks to expr = Scoring { scoring: ScoreRule { score_rule: Score { int: Literal { int: 1907751959 }, players: PlayerCollection { player_collection: Literal { players: [Query { query: Turnorder { int: Runtime { runtime: PlayRoundCounter } } }, Query { query: Turnorder { int: Aggregate { aggregate: SizeOf { collection: CardSet { card_set: GroupOwner { group: Groupable { groupable: LocationCollection { location_collection: LocationCollection { locations: ["S"] } } }, owner: PlayerCollection { player_collection: Literal { players: [Query { query: Turnorder { int: Literal { int: 1 } } }] } } } } } } } }] } } } } }
cc 01a8e7056a85eacc8abc2a207c4056836713fbb5a5cde02152e6ce472041c8f9 # shrinks to expr = Action { action: SetMemory { memory: "IdentTest", memory_type: CardSet { card_set: Group { group: Where { groupable: LocationCollection { location_collection: LocationCollection { locations: ["S"] } }, filter: Aggregate { aggregate: Combo { combo: "BASECASE" } } } } } } }
cc fc23a5e1c12f1aeaaa34dd5a03b22db17165a3dc3574de5802ae560041dfdc5c # shrinks to expr = SetUp { setup: CreateCardOnLocation { location: "IdentTest", types: Types { types: [("h", ["v"]), ("on", ["a"])] } } }
cc dd38f2ca409ed07638aca50c332772ec89ab33a73d4bedf256eaa265f2e4600a # shrinks to expr = SetUp { setup: CreateTeams { teams: [("identfallbackTa", Literal { players: [Literal { name: "P1" }] })] } }
cc 82a6b32b1a4d3d6353b12c0c74c1daf27c8a45e6e99618ff13699852ec3aeb89 # shrinks to expr = Scoring { scoring: ScoreRule { score_rule: Score { int: Aggregate { aggregate: SizeOf { collection: CardSet { card_set: Group { group: Where { groupable: Location { name: "tscv" }, filter: Aggregate { aggregate: Combo { combo: "BASECASE" } } } } } } }, players: Player { player: Literal { name: "P1" } } } } }
cc 5f48135cdf20686aea1dfade949f28a968cf91553dd0cee2b2efbb9b4b615d7b # shrinks to expr = SetUp { setup: CreatePlayer { players: [] } }
cc e4147394fe9e0d5417817164730cd83641f491b7c0750263981e0ac47ee1b5b5 # shrinks to expr = SetUp { setup: CreateLocation { locations: ["mxc", "upto", "identfallback", "identfallback", "identfallback"], owner: Player { player: Literal { name: "Pidentfallback" } } } }
cc 9151d92ac8c675d86564242042df671bb4dcf72fc417bbdb5c7b3ca8a53bfa34 # shrinks to expr = Action { action: FlipAction { card_set: Group { group: Groupable { groupable: Location { name: "default_loc" } } }, status: FaceUp } }
cc 07e7a036edb598da8327f75f9dafc97400edbb6fc8b4892ca8b7cebdce0d0b13 # shrinks to expr = Scoring { scoring: ScoreRule { score_rule: ScoreMemory { int: Binary { int: Query { query: IntCollectionAt { int_collection: IntCollection { ints: [Literal { int: 1577600000 }, Aggregate { aggregate: ExtremaIntCollection { extrema: Max, int_collection: IntCollection { ints: [Literal { int: -1207181833 }, Literal { int: -283320226 }, Runtime { runtime: PlayRoundCounter }] } } }, Aggregate { aggregate: ExtremaIntCollection { extrema: Max, int_collection: IntCollection { ints: [Binary { int: Literal { int: 1615620432 }, op: Mul, int1: Literal { int: 1800381363 } }, Runtime { runtime: StageRoundCounter }] } } }] }, int_expr: Runtime { runtime: PlayRoundCounter } } }, op: Mul, int1: Aggregate { aggregate: SumOfCardSet { card_set: Group { group: Where { groupable: Location { name: "wopqvjj" }, filter: Aggregate { aggregate: Same { key: "nevejem" } } } }, pointmap: "iltfzev" } } }, memory: "hzwcrlo", players: Player { player: Literal { name: "allpcnub" } } } } }
cc 7f903cbfbb3c4e0b191bad44ad503ee3b6e5f87511b41bbf7b3bf37a8a978d1e # shrinks to expr = Conditional { cases: [NoBool { flows: [Rule { game_rule: SetUp { setup: CreateCardOnLocation { location: "Qrjrjb", types: Types { types: [("Qdfnkmyqnon", ["Mboxx", "Pbagjcxm"])] } } } }] }, Bool { bool_expr: Aggregate { aggregate: Compare { cmp_bool: CardSet { card_set: Group { group: Groupable { groupable: Location { name: "Ruotrqxwmsg" } } }, cmp: Eq, card_set1: GroupOwner { group: Groupable { groupable: Location { name: "Defaultloc" } }, owner: Player { player: Literal { name: "Ythkncsq" } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }] }
cc 11f6cd82600cc39f07f96f46a6e56dd69d0766761fce2fd041165e7442e9ffe5 # shrinks to expr = ChoiceRule { options: [Rule { game_rule: SetUp { setup: CreateMemory { memory: "Id944", owner: Player { player: Literal { name: "Id831" } } } } }, Rule { game_rule: Scoring { scoring: ScoreRule { score_rule: ScoreMemory { int: Aggregate { aggregate: SumOfCardSet { card_set: Memory { memory: "Id100" }, pointmap: "Identfallback" } }, memory: "Identfallback", players: Player { player: Literal { name: "Identfallback" } } } } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc a5a30e1fee8bb66fb399c589cc29819153c72cdb6b074a4a8c62a93e7e1447de # shrinks to expr = Game { flows: [Rule { game_rule: Action { action: Move { move_type: Exchange { exchange: MoveCardSet { exchange_cs: MoveQuantity { quantity: IntRange { int_range: IntRange { start: (Ge, Literal { int: -2062416680 }), op_int: [(And, Gt, Runtime { runtime: PlayRoundCounter }), (Or, Eq, Binary { int: Runtime { runtime: PlayRoundCounter }, op: Plus, int1: Aggregate { aggregate: SumOfCardSet { card_set: Memory { memory: "Id100" }, pointmap: "Identfallback" } } })] } }, from: Group { group: Groupable { groupable: Location { name: "Defaultloc" } } }, status: FaceUp, to: Group { group: Groupable { groupable: Location { name: "Defaultloc" } } } } } } } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 209040354214032a52604ba2e5782e21f77ac116e104c73fdd195ce0caa4e5da # shrinks to expr = Conditional { cases: [NoBool { flows: [Rule { game_rule: Scoring { scoring: ScoreRule { score_rule: Score { int: Runtime { runtime: PlayRoundCounter }, players: Player { player: Query { query: Turnorder { int: Literal { int: -1375551171 } } } } } } } }, Rule { game_rule: Scoring { scoring: ScoreRule { score_rule: Score { int: Aggregate { aggregate: SumOfCardSet { card_set: Memory { memory: "Id100" }, pointmap: "Identfallback" } }, players: Player { player: Literal { name: "Identfallback" } } } } } }] }, NoBool { flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }] }
cc b30f835319dc71d890668a5a6c5e6f294f86b28fcfce26c0a2249a2c02c9391c # shrinks to expr = Conditional { cases: [Bool { bool_expr: Binary { bool_expr: Aggregate { aggregate: Compare { cmp_bool: CardSet { card_set: Group { group: Groupable { groupable: LocationCollection { location_collection: Memory { memory: "Id892" } } } }, cmp: Neq, card_set1: GroupOwner { group: Groupable { groupable: LocationCollection { location_collection: Memory { memory: "Id716" } } }, owner: Table } } } }, op: And, bool_expr1: Aggregate { aggregate: CardSetEmpty { card_set: Group { group: Groupable { groupable: Location { name: "BASECASE" } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }] }
cc 315cbc4acd52a1b107b8266ff2902f9a30efdf475b77207f4cb5bc8a76f6c78a # shrinks to expr = SeqStage { stage: "Id963", player: Runtime { runtime: Competitor }, end_condition: UntilBoolRep { bool_expr: Aggregate { aggregate: CardSetNotEmpty { card_set: GroupOwner { group: Where { groupable: LocationCollection { location_collection: Memory { memory: "Id834" } }, filter: Aggregate { aggregate: Combo { combo: "BASECASE" } } }, owner: Team { team: Literal { name: "TId100" } } } } }, logic: And, reps: Repititions { times: Literal { int: 1 } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 562bcc64040be56ba6cef4f3730535077b38452e644bfe0847b3c9a3cb777e74 # shrinks to expr = SeqStage { stage: "Id707", player: Query { query: Turnorder { int: Memory { memory: "Id982" } } }, end_condition: UntilRep { reps: Repititions { times: Literal { int: 1 } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 8c0aa15144374185b2609092c53786627a7448d503c86824616bd2c2eb429402 # shrinks to expr = OptionalRule { flows: [Rule { game_rule: SetUp { setup: CreateMemory { memory: "Id945", owner: Table } } }, Rule { game_rule: Action { action: Move { move_type: Classic { classic: MoveCardSet { move_cs: Move { from: Group { group: Where { groupable: LocationCollection { location_collection: Memory { memory: "Id261" } }, filter: Aggregate { aggregate: Combo { combo: "BASECASE" } } } }, status: FaceUp, to: Group { group: Groupable { groupable: Location { name: "Defaultloc" } } } } } } } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 1e46a114d255afab5e06c31ac98e31c93314d13011b70ee4fa0ffba7d6881400 # shrinks to expr = IfRule { condition: Aggregate { aggregate: Compare { cmp_bool: CardSet { card_set: Group { group: Groupable { groupable: LocationCollection { location_collection: Memory { memory: "Id634" } } } }, cmp: Eq, card_set1: Group { group: Where { groupable: LocationCollection { location_collection: Memory { memory: "Id506" } }, filter: Aggregate { aggregate: Combo { combo: "BASECASE" } } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 2a609e9710b32e4d6506613a6e0faf658aa3ea73e20a037131483483c43cc271 # shrinks to expr = Conditional { cases: [Bool { bool_expr: Aggregate { aggregate: Compare { cmp_bool: CardSet { card_set: Group { group: Groupable { groupable: LocationCollection { location_collection: Memory { memory: "Id832" } } } }, cmp: Neq, card_set1: GroupOwner { group: Groupable { groupable: LocationCollection { location_collection: Memory { memory: "Id581" } } }, owner: TeamCollection { team_collection: Runtime { runtime: OtherTeams } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }, Bool { bool_expr: Aggregate { aggregate: CardSetEmpty { card_set: Group { group: Groupable { groupable: Location { name: "BASECASE" } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }] }
cc c9b3f560cf44b11df92128b0ad554da05fa51f33a350c237f8240b305b125705 # shrinks to expr = Conditional { cases: [Bool { bool_expr: Binary { bool_expr: Aggregate { aggregate: Compare { cmp_bool: String { string: Memory { memory: "Id199" }, cmp: Eq, string1: Query { query: KeyOf { key: "Id100", card_position: Query { query: Top { location: "Deck" } } } } } } }, op: And, bool_expr1: Aggregate { aggregate: CardSetEmpty { card_set: Group { group: Groupable { groupable: Location { name: "BASECASE" } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }, NoBool { flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }] }
cc f945551a8f074be7a0e2f22d69e3013d274754074c469d9e6a9b0cbcdf4dad3f # shrinks to expr = IfRule { condition: Binary { bool_expr: Aggregate { aggregate: Compare { cmp_bool: String { string: Memory { memory: "Id716" }, cmp: Eq, string1: Query { query: StringCollectionAt { string_collection: Memory { memory: "Id100" }, int_expr: Literal { int: 1 } } } } } }, op: And, bool_expr1: Aggregate { aggregate: CardSetEmpty { card_set: Group { group: Groupable { groupable: Location { name: "BASECASE" } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 023e7d2c131d175e725bbde9d00692243bc27ffbc99e2d9ab8a112a122821b0c # shrinks to expr = Game { flows: [Rule { game_rule: Scoring { scoring: ScoreRule { score_rule: ScoreMemory { int: Aggregate { aggregate: ExtremaCardset { extrema: Min, card_set: GroupOwner { group: Where { groupable: Location { name: "Id948" }, filter: Aggregate { aggregate: Size { cmp: Gt, int_expr: Aggregate { aggregate: SumOfIntCollection { int_collection: Memory { memory: "Id363" } } } } } }, owner: Team { team: Literal { name: "TIdentfallback" } } }, pointmap: "Identfallback" } }, memory: "Identfallback", players: Player { player: Literal { name: "PIdentfallback" } } } } } }] }
cc 014f9d3b09985f793d0c24b47a41e6e2ccd3f2bfdc0c12758529a9e55c1cf262 # shrinks to expr = ChoiceRule { options: [Rule { game_rule: SetUp { setup: CreateCombo { combo: "Id565", filter: Binary { filter: Aggregate { aggregate: Adjacent { key: "Id955", precedence: "Id100" } }, op: And, filter1: Aggregate { aggregate: Combo { combo: "BASECASE" } } } } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 2223051a21bbb14f6c1dabf793013d77cff229e4dcece2213042d98ed5ac0c31 # shrinks to expr = Game { flows: [Rule { game_rule: SetUp { setup: CreateCombo { combo: "Id937", filter: Aggregate { aggregate: Adjacent { key: "Id249", precedence: "Id100" } } } } }] }
cc b020e163f3ce83ccc3efb32ce0b9a368b3d3ce0b645ebe8f5796881bce4f9b68 # shrinks to expr = SetUp { setup: CreateCombo { combo: "Id663", filter: Binary { filter: Aggregate { aggregate: Adjacent { key: "Id590", precedence: "Id100" } }, op: And, filter1: Aggregate { aggregate: Combo { combo: "BASECASE" } } } } }
cc 7b78dccd0084627ab14b4e440513b25ed334372c6e4a4181cb71a67b8cf08aaf # shrinks to expr = Conditional { cases: [NoBool { flows: [Rule { game_rule: Action { action: ShuffleAction { card_set: Group { group: Where { groupable: LocationCollection { location_collection: Memory { memory: "Id505" } }, filter: Aggregate { aggregate: Adjacent { key: "Id141", precedence: "Id100" } } } } } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }, NoBool { flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }] }
cc 781d3e37e7bd86db7fbd11185d3a8e078e34dc4d8a40056e2b8b1914a3061e88 # shrinks to expr = Action { action: ShuffleAction { card_set: Group { group: Where { groupable: LocationCollection { location_collection: Memory { memory: "Id500" } }, filter: Aggregate { aggregate: Combo { combo: "BASECASE" } } } } } }
cc 1ab6dc891bbc6e2e6f5012f4b83d8c8aea56c0217f7a55f912a26c830e6b2d50 # shrinks to expr = SeqStage { stage: "Id357", player: Query { query: Turnorder { int: Aggregate { aggregate: ExtremaCardset { extrema: Min, card_set: Group { group: Where { groupable: LocationCollection { location_collection: Memory { memory: "Id509" } }, filter: Aggregate { aggregate: Combo { combo: "BASECASE" } } } }, pointmap: "Id100" } } } }, end_condition: UntilBool { bool_expr: Aggregate { aggregate: CardSetEmpty { card_set: Group { group: Groupable { groupable: Location { name: "BASECASE" } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 008d9a925933f7c1980fdba53d2493ee7feefc8ff40ab667f3c04a21be9fbbc1 # shrinks to expr = SetUp { setup: CreateMemory { memory: "Id603", owner: TeamCollection { team_collection: Memory { memory: "Id100" } } } }
cc 3ecd7a6eff9f89d3efb61635c37e69b29d4228d462edd004fe76d5b90e3cfda6 # shrinks to expr = SetUp { setup: CreateMemoryWithMemoryType { memory: "Id890", memory_type: IntCollection { ints: Memory { memory: "Identfallback" } }, owner: Player { player: Literal { name: "PIdentfallback" } } } }
cc a2a4c1aa9f82f8d4666e77bda3a720f8a4a91150b71563ea7dd629b56f0f5d5d # shrinks to expr = SetUp { setup: CreateMemoryWithMemoryType { memory: "Id992", memory_type: CardSet { card_set: Group { group: Groupable { groupable: Location { name: "Defaultloc" } } } }, owner: Player { player: Literal { name: "PIdentfallback" } } } }
cc 0de0c81994eea6262ae04c7dcf4a0939a3ea662362e780ee0280b4b3058c4029 # shrinks to expr = Game { flows: [Rule { game_rule: Action { action: SetMemory { memory: "Id683", memory_type: String { string: Query { query: StringCollectionAt { string_collection: Memory { memory: WithOwner { memory: "Id100", owner: Player { player: Literal { name: "PIdentfallback" } } } }, int_expr: Literal { int: 1 } } } } } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 0d2944c7f179de80deb023dda520bcca29ffc386c0423b5e1a1fa7b9fcb40e30 # shrinks to expr = ChoiceRule { options: [Rule { game_rule: SetUp { setup: CreateMemoryWithMemoryType { memory: "Id534", memory_type: String { string: Query { query: StringCollectionAt { string_collection: Memory { memory: Memory { memory: "Id100" } }, int_expr: Literal { int: 1 } } } }, owner: Player { player: Literal { name: "PIdentfallback" } } } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc fd9d1b6e92be690f0d157002cc368b86723a459e80f194ac41e5fc11ae75423f # shrinks to expr = Action { action: SetMemory { memory: "Id380", memory_type: Int { int: Query { query: IntCollectionAt { int_collection: Memory { memory: WithOwner { memory: "Id100", owner: Player { player: Literal { name: "PIdentfallback" } } } }, int_expr: Literal { int: 1 } } } } } }
cc c645d269e1f1660d6ed57e819b175aa71b4b9c0a0e46f4585c5847fe41fe6497 # shrinks to expr = Conditional { cases: [NoBool { flows: [Rule { game_rule: SetUp { setup: CreateTurnorder { player_collection: Runtime { runtime: PlayersIn } } } }, Rule { game_rule: SetUp { setup: CreateMemoryWithMemoryType { memory: "Id499", memory_type: String { string: Query { query: StringCollectionAt { string_collection: Memory { memory: Memory { memory: "Identfallback" } }, int_expr: Literal { int: 1 } } } }, owner: Player { player: Literal { name: "PIdentfallback" } } } } }] }, NoBool { flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }] }
cc eb97ad1dc0f4ec2fcd2c9a7a6f62632b1fa17f7fc48ca1f4906fecccdbe94643 # shrinks to expr = IfRule { condition: Aggregate { aggregate: OutOfPlayer { players: PlayerCollection { player_collection: Aggregate { aggregate: Quantifier { quantifier: All } } }, out_of: CurrentStage } }, flows: [Rule { game_rule: Action { action: SetMemory { memory: "Id808", memory_type: String { string: Query { query: StringCollectionAt { string_collection: Memory { memory: Memory { memory: "Id100" } }, int_expr: Literal { int: 1 } } } } } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 3914325f39f80ef2960e4b453616ff29cd97253f4b29b19e9a67d73644603f53 # shrinks to expr = SeqStage { stage: "Id642", player: Runtime { runtime: Next }, end_condition: UntilEnd, flows: [Rule { game_rule: SetUp { setup: CreateMemoryWithMemoryType { memory: "Id399", memory_type: Int { int: Query { query: IntCollectionAt { int_collection: Memory { memory: WithOwner { memory: "Id100", owner: Player { player: Literal { name: "PIdentfallback" } } } }, int_expr: Literal { int: 1 } } } }, owner: Player { player: Literal { name: "PIdentfallback" } } } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
