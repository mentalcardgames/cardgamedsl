# Seeds for failure cases proptest has generated in the past. It is
# automatically read and these particular cases re-run before any
# novel cases are generated.
#
# It is recommended to check this file in to source control so that
# everyone who runs the test benefits from these saved cases.
cc 22e60919cd334ebff74dcb1785097066dd9fd7c27474b1a4b4283a05a9b1bae2 # shrinks to expr = Game { flows: [] }
cc 11caf8307cba7f981eac24d109e2c803e74c244f3c6e9cc3a7163b06fcea64c0 # shrinks to expr = Game { flows: [Conditional(Conditional { cases: [Bool(Aggregate(OutOfPlayer(Player(Aggregate(OwnerOfCardPostion(Query(Bottom(""))))), Stage(""))), [Stage(SeqStage { stage: "", player: Query(Turnorder(Aggregate(ExtremaIntCollection(Max, IntCollection { ints: [] })))), end_condition: UntilEnd, flows: [] })]), Bool(Unary(Not, Unary(Not, Aggregate(Compare(Int(Literal(0), Eq, Literal(0)))))), [])] })] }
cc 4c295c67eefad96fd48eb20406ed04baa11c93bff2d7043f192a75c5261d8b92 # shrinks to expr = Action { action: BidAction { quantitiy: Int { int: Aggregate { aggregate: SumOfCardSet { card_set: Group { group: NotCombo { combo: "IdentTest", groupable: LocationCollection { location_collection: LocationCollection { locations: ["S"] } } } }, pointmap: "IdentTest" } } } } }
cc 7a81948f2d52b4857cb669aeda5c7ec87bbc0d53994965031e8723a5cbc8d5f2 # shrinks to expr = Action { action: BidAction { quantitiy: IntRange { int_range: IntRange { start: (Eq, Literal { int: 1 }), op_int: [(And, Eq, Literal { int: 1 })] } } } }
cc 125e20186dd7733592b928b260448a868a02505080651e547ccec45c1b82f5df # shrinks to expr = SetUp { setup: CreateLocation { locations: [""], owner: Player { player: Literal { name: "P1" } } } }
cc 6a3c21704162e691dab339b67d9f88150517f9371e5af67e4d5a2bc23c872511 # shrinks to expr = Action { action: PlayerOutOfStageAction { players: PlayerCollection { player_collection: Literal { players: [Aggregate { aggregate: OwnerOfCardPostion { card_position: Query { query: At { location: "IdentTest", int_expr: Binary { int: Runtime { runtime: PlayRoundCounter }, op: Div, int1: Binary { int: Aggregate { aggregate: SumOfIntCollection { int_collection: IntCollection { ints: [Runtime { runtime: PlayRoundCounter }] } } }, op: Minus, int1: Query { query: IntCollectionAt { int_collection: IntCollection { ints: [Binary { int: Literal { int: 697424827 }, op: Minus, int1: Query { query: IntCollectionAt { int_collection: IntCollection { ints: [Runtime { runtime: StageRoundCounter }, Binary { int: Binary { int: Query { query: IntCollectionAt { int_collection: IntCollection { ints: [Binary { int: Runtime { runtime: PlayRoundCounter }, op: Minus, int1: Runtime { runtime: PlayRoundCounter } }] }, int_expr: Literal { int: 1853701751 } } }, op: Minus, int1: Runtime { runtime: PlayRoundCounter } }, op: Plus, int1: Aggregate { aggregate: SumOfCardSet { card_set: Group { group: Where { groupable: Location { name: "IdentTest" }, filter: Aggregate { aggregate: Combo { combo: "BASE_CASE" } } } }, pointmap: "IdentTest" } } }] }, int_expr: Literal { int: 1 } } } }, Literal { int: 1 }] }, int_expr: Literal { int: 1 } } } } } } } } }, Literal { name: "P1" }] } } } }
cc a97a50bdc328fe69e8e10732f90b4b9b96391089415825f3641fee4786394434 # shrinks to expr = Action { action: EndAction { end_type: Turn } }
cc ac3fda110d644df489b08414917d25297d994956ae510fcdcf83ac9f69cd566f # shrinks to expr = SetUp { setup: CreateCardOnLocation { location: "IdentTest", types: Types { types: [("upa", ["a"])] } } }
cc f8b9a5418f5c2d3568c8979ffde21368710276b75a863ce86549d8044ec01a20 # shrinks to expr = Scoring { scoring: ScoreRule { score_rule: Score { int: Literal { int: 1907751959 }, players: PlayerCollection { player_collection: Literal { players: [Query { query: Turnorder { int: Runtime { runtime: PlayRoundCounter } } }, Query { query: Turnorder { int: Aggregate { aggregate: SizeOf { collection: CardSet { card_set: GroupOwner { group: Groupable { groupable: LocationCollection { location_collection: LocationCollection { locations: ["S"] } } }, owner: PlayerCollection { player_collection: Literal { players: [Query { query: Turnorder { int: Literal { int: 1 } } }] } } } } } } } }] } } } } }
cc 01a8e7056a85eacc8abc2a207c4056836713fbb5a5cde02152e6ce472041c8f9 # shrinks to expr = Action { action: SetMemory { memory: "IdentTest", memory_type: CardSet { card_set: Group { group: Where { groupable: LocationCollection { location_collection: LocationCollection { locations: ["S"] } }, filter: Aggregate { aggregate: Combo { combo: "BASECASE" } } } } } } }
cc fc23a5e1c12f1aeaaa34dd5a03b22db17165a3dc3574de5802ae560041dfdc5c # shrinks to expr = SetUp { setup: CreateCardOnLocation { location: "IdentTest", types: Types { types: [("h", ["v"]), ("on", ["a"])] } } }
cc dd38f2ca409ed07638aca50c332772ec89ab33a73d4bedf256eaa265f2e4600a # shrinks to expr = SetUp { setup: CreateTeams { teams: [("identfallbackTa", Literal { players: [Literal { name: "P1" }] })] } }
cc 82a6b32b1a4d3d6353b12c0c74c1daf27c8a45e6e99618ff13699852ec3aeb89 # shrinks to expr = Scoring { scoring: ScoreRule { score_rule: Score { int: Aggregate { aggregate: SizeOf { collection: CardSet { card_set: Group { group: Where { groupable: Location { name: "tscv" }, filter: Aggregate { aggregate: Combo { combo: "BASECASE" } } } } } } }, players: Player { player: Literal { name: "P1" } } } } }
cc 5f48135cdf20686aea1dfade949f28a968cf91553dd0cee2b2efbb9b4b615d7b # shrinks to expr = SetUp { setup: CreatePlayer { players: [] } }
cc e4147394fe9e0d5417817164730cd83641f491b7c0750263981e0ac47ee1b5b5 # shrinks to expr = SetUp { setup: CreateLocation { locations: ["mxc", "upto", "identfallback", "identfallback", "identfallback"], owner: Player { player: Literal { name: "Pidentfallback" } } } }
cc 9151d92ac8c675d86564242042df671bb4dcf72fc417bbdb5c7b3ca8a53bfa34 # shrinks to expr = Action { action: FlipAction { card_set: Group { group: Groupable { groupable: Location { name: "default_loc" } } }, status: FaceUp } }
cc 07e7a036edb598da8327f75f9dafc97400edbb6fc8b4892ca8b7cebdce0d0b13 # shrinks to expr = Scoring { scoring: ScoreRule { score_rule: ScoreMemory { int: Binary { int: Query { query: IntCollectionAt { int_collection: IntCollection { ints: [Literal { int: 1577600000 }, Aggregate { aggregate: ExtremaIntCollection { extrema: Max, int_collection: IntCollection { ints: [Literal { int: -1207181833 }, Literal { int: -283320226 }, Runtime { runtime: PlayRoundCounter }] } } }, Aggregate { aggregate: ExtremaIntCollection { extrema: Max, int_collection: IntCollection { ints: [Binary { int: Literal { int: 1615620432 }, op: Mul, int1: Literal { int: 1800381363 } }, Runtime { runtime: StageRoundCounter }] } } }] }, int_expr: Runtime { runtime: PlayRoundCounter } } }, op: Mul, int1: Aggregate { aggregate: SumOfCardSet { card_set: Group { group: Where { groupable: Location { name: "wopqvjj" }, filter: Aggregate { aggregate: Same { key: "nevejem" } } } }, pointmap: "iltfzev" } } }, memory: "hzwcrlo", players: Player { player: Literal { name: "allpcnub" } } } } }
cc 7f903cbfbb3c4e0b191bad44ad503ee3b6e5f87511b41bbf7b3bf37a8a978d1e # shrinks to expr = Conditional { cases: [NoBool { flows: [Rule { game_rule: SetUp { setup: CreateCardOnLocation { location: "Qrjrjb", types: Types { types: [("Qdfnkmyqnon", ["Mboxx", "Pbagjcxm"])] } } } }] }, Bool { bool_expr: Aggregate { aggregate: Compare { cmp_bool: CardSet { card_set: Group { group: Groupable { groupable: Location { name: "Ruotrqxwmsg" } } }, cmp: Eq, card_set1: GroupOwner { group: Groupable { groupable: Location { name: "Defaultloc" } }, owner: Player { player: Literal { name: "Ythkncsq" } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }] }
cc 11f6cd82600cc39f07f96f46a6e56dd69d0766761fce2fd041165e7442e9ffe5 # shrinks to expr = ChoiceRule { options: [Rule { game_rule: SetUp { setup: CreateMemory { memory: "Id944", owner: Player { player: Literal { name: "Id831" } } } } }, Rule { game_rule: Scoring { scoring: ScoreRule { score_rule: ScoreMemory { int: Aggregate { aggregate: SumOfCardSet { card_set: Memory { memory: "Id100" }, pointmap: "Identfallback" } }, memory: "Identfallback", players: Player { player: Literal { name: "Identfallback" } } } } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc a5a30e1fee8bb66fb399c589cc29819153c72cdb6b074a4a8c62a93e7e1447de # shrinks to expr = Game { flows: [Rule { game_rule: Action { action: Move { move_type: Exchange { exchange: MoveCardSet { exchange_cs: MoveQuantity { quantity: IntRange { int_range: IntRange { start: (Ge, Literal { int: -2062416680 }), op_int: [(And, Gt, Runtime { runtime: PlayRoundCounter }), (Or, Eq, Binary { int: Runtime { runtime: PlayRoundCounter }, op: Plus, int1: Aggregate { aggregate: SumOfCardSet { card_set: Memory { memory: "Id100" }, pointmap: "Identfallback" } } })] } }, from: Group { group: Groupable { groupable: Location { name: "Defaultloc" } } }, status: FaceUp, to: Group { group: Groupable { groupable: Location { name: "Defaultloc" } } } } } } } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 209040354214032a52604ba2e5782e21f77ac116e104c73fdd195ce0caa4e5da # shrinks to expr = Conditional { cases: [NoBool { flows: [Rule { game_rule: Scoring { scoring: ScoreRule { score_rule: Score { int: Runtime { runtime: PlayRoundCounter }, players: Player { player: Query { query: Turnorder { int: Literal { int: -1375551171 } } } } } } } }, Rule { game_rule: Scoring { scoring: ScoreRule { score_rule: Score { int: Aggregate { aggregate: SumOfCardSet { card_set: Memory { memory: "Id100" }, pointmap: "Identfallback" } }, players: Player { player: Literal { name: "Identfallback" } } } } } }] }, NoBool { flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }] }
cc b30f835319dc71d890668a5a6c5e6f294f86b28fcfce26c0a2249a2c02c9391c # shrinks to expr = Conditional { cases: [Bool { bool_expr: Binary { bool_expr: Aggregate { aggregate: Compare { cmp_bool: CardSet { card_set: Group { group: Groupable { groupable: LocationCollection { location_collection: Memory { memory: "Id892" } } } }, cmp: Neq, card_set1: GroupOwner { group: Groupable { groupable: LocationCollection { location_collection: Memory { memory: "Id716" } } }, owner: Table } } } }, op: And, bool_expr1: Aggregate { aggregate: CardSetEmpty { card_set: Group { group: Groupable { groupable: Location { name: "BASECASE" } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }] }
cc 315cbc4acd52a1b107b8266ff2902f9a30efdf475b77207f4cb5bc8a76f6c78a # shrinks to expr = SeqStage { stage: "Id963", player: Runtime { runtime: Competitor }, end_condition: UntilBoolRep { bool_expr: Aggregate { aggregate: CardSetNotEmpty { card_set: GroupOwner { group: Where { groupable: LocationCollection { location_collection: Memory { memory: "Id834" } }, filter: Aggregate { aggregate: Combo { combo: "BASECASE" } } }, owner: Team { team: Literal { name: "TId100" } } } } }, logic: And, reps: Repititions { times: Literal { int: 1 } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 562bcc64040be56ba6cef4f3730535077b38452e644bfe0847b3c9a3cb777e74 # shrinks to expr = SeqStage { stage: "Id707", player: Query { query: Turnorder { int: Memory { memory: "Id982" } } }, end_condition: UntilRep { reps: Repititions { times: Literal { int: 1 } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 8c0aa15144374185b2609092c53786627a7448d503c86824616bd2c2eb429402 # shrinks to expr = OptionalRule { flows: [Rule { game_rule: SetUp { setup: CreateMemory { memory: "Id945", owner: Table } } }, Rule { game_rule: Action { action: Move { move_type: Classic { classic: MoveCardSet { move_cs: Move { from: Group { group: Where { groupable: LocationCollection { location_collection: Memory { memory: "Id261" } }, filter: Aggregate { aggregate: Combo { combo: "BASECASE" } } } }, status: FaceUp, to: Group { group: Groupable { groupable: Location { name: "Defaultloc" } } } } } } } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 1e46a114d255afab5e06c31ac98e31c93314d13011b70ee4fa0ffba7d6881400 # shrinks to expr = IfRule { condition: Aggregate { aggregate: Compare { cmp_bool: CardSet { card_set: Group { group: Groupable { groupable: LocationCollection { location_collection: Memory { memory: "Id634" } } } }, cmp: Eq, card_set1: Group { group: Where { groupable: LocationCollection { location_collection: Memory { memory: "Id506" } }, filter: Aggregate { aggregate: Combo { combo: "BASECASE" } } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 2a609e9710b32e4d6506613a6e0faf658aa3ea73e20a037131483483c43cc271 # shrinks to expr = Conditional { cases: [Bool { bool_expr: Aggregate { aggregate: Compare { cmp_bool: CardSet { card_set: Group { group: Groupable { groupable: LocationCollection { location_collection: Memory { memory: "Id832" } } } }, cmp: Neq, card_set1: GroupOwner { group: Groupable { groupable: LocationCollection { location_collection: Memory { memory: "Id581" } } }, owner: TeamCollection { team_collection: Runtime { runtime: OtherTeams } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }, Bool { bool_expr: Aggregate { aggregate: CardSetEmpty { card_set: Group { group: Groupable { groupable: Location { name: "BASECASE" } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }] }
cc c9b3f560cf44b11df92128b0ad554da05fa51f33a350c237f8240b305b125705 # shrinks to expr = Conditional { cases: [Bool { bool_expr: Binary { bool_expr: Aggregate { aggregate: Compare { cmp_bool: String { string: Memory { memory: "Id199" }, cmp: Eq, string1: Query { query: KeyOf { key: "Id100", card_position: Query { query: Top { location: "Deck" } } } } } } }, op: And, bool_expr1: Aggregate { aggregate: CardSetEmpty { card_set: Group { group: Groupable { groupable: Location { name: "BASECASE" } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }, NoBool { flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }] }
cc f945551a8f074be7a0e2f22d69e3013d274754074c469d9e6a9b0cbcdf4dad3f # shrinks to expr = IfRule { condition: Binary { bool_expr: Aggregate { aggregate: Compare { cmp_bool: String { string: Memory { memory: "Id716" }, cmp: Eq, string1: Query { query: StringCollectionAt { string_collection: Memory { memory: "Id100" }, int_expr: Literal { int: 1 } } } } } }, op: And, bool_expr1: Aggregate { aggregate: CardSetEmpty { card_set: Group { group: Groupable { groupable: Location { name: "BASECASE" } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 023e7d2c131d175e725bbde9d00692243bc27ffbc99e2d9ab8a112a122821b0c # shrinks to expr = Game { flows: [Rule { game_rule: Scoring { scoring: ScoreRule { score_rule: ScoreMemory { int: Aggregate { aggregate: ExtremaCardset { extrema: Min, card_set: GroupOwner { group: Where { groupable: Location { name: "Id948" }, filter: Aggregate { aggregate: Size { cmp: Gt, int_expr: Aggregate { aggregate: SumOfIntCollection { int_collection: Memory { memory: "Id363" } } } } } }, owner: Team { team: Literal { name: "TIdentfallback" } } }, pointmap: "Identfallback" } }, memory: "Identfallback", players: Player { player: Literal { name: "PIdentfallback" } } } } } }] }
cc 014f9d3b09985f793d0c24b47a41e6e2ccd3f2bfdc0c12758529a9e55c1cf262 # shrinks to expr = ChoiceRule { options: [Rule { game_rule: SetUp { setup: CreateCombo { combo: "Id565", filter: Binary { filter: Aggregate { aggregate: Adjacent { key: "Id955", precedence: "Id100" } }, op: And, filter1: Aggregate { aggregate: Combo { combo: "BASECASE" } } } } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 2223051a21bbb14f6c1dabf793013d77cff229e4dcece2213042d98ed5ac0c31 # shrinks to expr = Game { flows: [Rule { game_rule: SetUp { setup: CreateCombo { combo: "Id937", filter: Aggregate { aggregate: Adjacent { key: "Id249", precedence: "Id100" } } } } }] }
cc b020e163f3ce83ccc3efb32ce0b9a368b3d3ce0b645ebe8f5796881bce4f9b68 # shrinks to expr = SetUp { setup: CreateCombo { combo: "Id663", filter: Binary { filter: Aggregate { aggregate: Adjacent { key: "Id590", precedence: "Id100" } }, op: And, filter1: Aggregate { aggregate: Combo { combo: "BASECASE" } } } } }
cc 7b78dccd0084627ab14b4e440513b25ed334372c6e4a4181cb71a67b8cf08aaf # shrinks to expr = Conditional { cases: [NoBool { flows: [Rule { game_rule: Action { action: ShuffleAction { card_set: Group { group: Where { groupable: LocationCollection { location_collection: Memory { memory: "Id505" } }, filter: Aggregate { aggregate: Adjacent { key: "Id141", precedence: "Id100" } } } } } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }, NoBool { flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }] }
cc 781d3e37e7bd86db7fbd11185d3a8e078e34dc4d8a40056e2b8b1914a3061e88 # shrinks to expr = Action { action: ShuffleAction { card_set: Group { group: Where { groupable: LocationCollection { location_collection: Memory { memory: "Id500" } }, filter: Aggregate { aggregate: Combo { combo: "BASECASE" } } } } } }
cc 1ab6dc891bbc6e2e6f5012f4b83d8c8aea56c0217f7a55f912a26c830e6b2d50 # shrinks to expr = SeqStage { stage: "Id357", player: Query { query: Turnorder { int: Aggregate { aggregate: ExtremaCardset { extrema: Min, card_set: Group { group: Where { groupable: LocationCollection { location_collection: Memory { memory: "Id509" } }, filter: Aggregate { aggregate: Combo { combo: "BASECASE" } } } }, pointmap: "Id100" } } } }, end_condition: UntilBool { bool_expr: Aggregate { aggregate: CardSetEmpty { card_set: Group { group: Groupable { groupable: Location { name: "BASECASE" } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 008d9a925933f7c1980fdba53d2493ee7feefc8ff40ab667f3c04a21be9fbbc1 # shrinks to expr = SetUp { setup: CreateMemory { memory: "Id603", owner: TeamCollection { team_collection: Memory { memory: "Id100" } } } }
cc 3ecd7a6eff9f89d3efb61635c37e69b29d4228d462edd004fe76d5b90e3cfda6 # shrinks to expr = SetUp { setup: CreateMemoryWithMemoryType { memory: "Id890", memory_type: IntCollection { ints: Memory { memory: "Identfallback" } }, owner: Player { player: Literal { name: "PIdentfallback" } } } }
cc a2a4c1aa9f82f8d4666e77bda3a720f8a4a91150b71563ea7dd629b56f0f5d5d # shrinks to expr = SetUp { setup: CreateMemoryWithMemoryType { memory: "Id992", memory_type: CardSet { card_set: Group { group: Groupable { groupable: Location { name: "Defaultloc" } } } }, owner: Player { player: Literal { name: "PIdentfallback" } } } }
cc 0de0c81994eea6262ae04c7dcf4a0939a3ea662362e780ee0280b4b3058c4029 # shrinks to expr = Game { flows: [Rule { game_rule: Action { action: SetMemory { memory: "Id683", memory_type: String { string: Query { query: StringCollectionAt { string_collection: Memory { memory: WithOwner { memory: "Id100", owner: Player { player: Literal { name: "PIdentfallback" } } } }, int_expr: Literal { int: 1 } } } } } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 0d2944c7f179de80deb023dda520bcca29ffc386c0423b5e1a1fa7b9fcb40e30 # shrinks to expr = ChoiceRule { options: [Rule { game_rule: SetUp { setup: CreateMemoryWithMemoryType { memory: "Id534", memory_type: String { string: Query { query: StringCollectionAt { string_collection: Memory { memory: Memory { memory: "Id100" } }, int_expr: Literal { int: 1 } } } }, owner: Player { player: Literal { name: "PIdentfallback" } } } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc fd9d1b6e92be690f0d157002cc368b86723a459e80f194ac41e5fc11ae75423f # shrinks to expr = Action { action: SetMemory { memory: "Id380", memory_type: Int { int: Query { query: IntCollectionAt { int_collection: Memory { memory: WithOwner { memory: "Id100", owner: Player { player: Literal { name: "PIdentfallback" } } } }, int_expr: Literal { int: 1 } } } } } }
cc c645d269e1f1660d6ed57e819b175aa71b4b9c0a0e46f4585c5847fe41fe6497 # shrinks to expr = Conditional { cases: [NoBool { flows: [Rule { game_rule: SetUp { setup: CreateTurnorder { player_collection: Runtime { runtime: PlayersIn } } } }, Rule { game_rule: SetUp { setup: CreateMemoryWithMemoryType { memory: "Id499", memory_type: String { string: Query { query: StringCollectionAt { string_collection: Memory { memory: Memory { memory: "Identfallback" } }, int_expr: Literal { int: 1 } } } }, owner: Player { player: Literal { name: "PIdentfallback" } } } } }] }, NoBool { flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }] }
cc eb97ad1dc0f4ec2fcd2c9a7a6f62632b1fa17f7fc48ca1f4906fecccdbe94643 # shrinks to expr = IfRule { condition: Aggregate { aggregate: OutOfPlayer { players: PlayerCollection { player_collection: Aggregate { aggregate: Quantifier { quantifier: All } } }, out_of: CurrentStage } }, flows: [Rule { game_rule: Action { action: SetMemory { memory: "Id808", memory_type: String { string: Query { query: StringCollectionAt { string_collection: Memory { memory: Memory { memory: "Id100" } }, int_expr: Literal { int: 1 } } } } } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 3914325f39f80ef2960e4b453616ff29cd97253f4b29b19e9a67d73644603f53 # shrinks to expr = SeqStage { stage: "Id642", player: Runtime { runtime: Next }, end_condition: UntilEnd, flows: [Rule { game_rule: SetUp { setup: CreateMemoryWithMemoryType { memory: "Id399", memory_type: Int { int: Query { query: IntCollectionAt { int_collection: Memory { memory: WithOwner { memory: "Id100", owner: Player { player: Literal { name: "PIdentfallback" } } } }, int_expr: Literal { int: 1 } } } }, owner: Player { player: Literal { name: "PIdentfallback" } } } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc ce36e897e09340c78625435fe083cc4f7ad583390015404d9399bc1681467cda # shrinks to expr = Action { action: EndAction { end_type: Stage { stage: "" } } }
cc a61b42e8527df49c7d5e47ac0906fe99fd80ff1889468cd4affd0049b81e19f9 # shrinks to expr = Scoring { scoring: ScoreRule { score_rule: ScoreMemory { int: Memory { memory: Memory { memory: "Id464" } }, memory: "Id111", players: Player { player: Query { query: CollectionAt { players: Runtime { runtime: PlayersIn }, int: Literal { int: 1 } } } } } } }
cc 4bd2d4a0bdf05328a95cec89f64de30c7ad5e9aac73731907b10393fa77c289e # shrinks to expr = SimStage { stage: "Id462", players: Aggregate { aggregate: Quantifier { quantifier: Any } }, end_condition: UntilEnd, flows: [Rule { game_rule: Action { action: PlayerOutOfStageAction { players: Player { player: Query { query: CollectionAt { players: Literal { players: [Aggregate { aggregate: OwnerOfCardPostion { card_position: Query { query: Bottom { location: "Id700" } } } }] }, int: Literal { int: 1 } } } } } } }] }
cc 0dd972aabcce1ed69984cc6e8b46fc907261af45f057ebfdd930c07e5c532879 # shrinks to expr = SeqStage { stage: "Id319", player: Runtime { runtime: Competitor }, end_condition: UntilEnd, flows: [Rule { game_rule: Scoring { scoring: ScoreRule { score_rule: Score { int: Memory { memory: Memory { memory: "Id467" } }, players: Player { player: Query { query: CollectionAt { players: Runtime { runtime: PlayersIn }, int: Literal { int: 1 } } } } } } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 6324b31768431fd6c465ccee6498cf6c3acd787451d0adc606fe22a0c7b82b18 # shrinks to expr = Game { flows: [Rule { game_rule: Scoring { scoring: ScoreRule { score_rule: Score { int: Query { query: IntCollectionAt { int_collection: Literal { ints: [Query { query: IntCollectionAt { int_collection: Literal { ints: [Aggregate { aggregate: ExtremaCardset { extrema: Min, card_set: Memory { memory: WithOwner { memory: "Id810", owner: Player { player: Query { query: CollectionAt { players: Literal { players: [Literal { name: "Id100" }] }, int: Literal { int: 1 } } } } } }, pointmap: "Identfallback" } }, Literal { int: 1 }, Literal { int: 1 }] }, int_expr: Literal { int: 1 } } }, Literal { int: 1 }] }, int_expr: Literal { int: 1 } } }, players: Player { player: Literal { name: "Identfallback" } } } } } }] }
cc a049ebd2ec07de4f3567b53f2241e4ccb9c76f818843a93b041eddbf1651402c # shrinks to expr = Action { action: BidMemoryAction { memory: "Id937", quantity: Quantifier { qunatifier: All }, owner: Player { player: Query { query: CollectionAt { players: Literal { players: [Literal { name: "Id100" }] }, int: Literal { int: 1 } } } } } }
cc c1faad4fec424e27ad4fee7fb03d02de6f617ab0db4b8c120a2580c5315fb186 # shrinks to expr = Conditional { cases: [Bool { bool_expr: Aggregate { aggregate: Compare { cmp_bool: CardSet { card_set: Memory { memory: WithOwner { memory: "Id689", owner: Player { player: Query { query: CollectionAt { players: Literal { players: [Literal { name: "Id100" }, Literal { name: "Identfallback" }] }, int: Literal { int: 1 } } } } } }, cmp: Eq, card_set1: Group { group: Groupable { groupable: Location { name: "Defaultloc" } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }, NoBool { flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }] }
cc 30cbd58dbcfbbbe014e7022ec77a4c2b16bc7eb9b246e588a18d8851ca68646a # shrinks to expr = ChoiceRule { options: [Rule { game_rule: SetUp { setup: CreateMemory { memory: "Id545", owner: Player { player: Query { query: CollectionAt { players: Memory { memory: Memory { memory: "Id100" } }, int: Literal { int: 1 } } } } } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 9c7d48ab5e2c340606125689fc1098340c3eafb1fda597980212e8e03dfc774b # shrinks to expr = IfRule { condition: Unary { op: Not, bool_expr: Aggregate { aggregate: CardSetEmpty { card_set: GroupOwner { group: Groupable { groupable: Location { name: "Id586" } }, owner: Player { player: Query { query: CollectionAt { players: Literal { players: [Literal { name: "Id100" }] }, int: Literal { int: 1 } } } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 8476cb788b857178155b6b85ce8b6fb6358c1a84ddac5f5bdc30cc538203517b # shrinks to expr = SeqStage { stage: "Id210", player: Literal { name: "Id362" }, end_condition: UntilBoolRep { bool_expr: Aggregate { aggregate: CardSetEmpty { card_set: Group { group: Groupable { groupable: Location { name: "BASECASE" } } } } }, logic: And, reps: Repititions { times: Aggregate { aggregate: SumOfCardSet { card_set: GroupOwner { group: Groupable { groupable: Location { name: "Defaultloc" } }, owner: Player { player: Query { query: CollectionAt { players: Memory { memory: Memory { memory: "Id100" } }, int: Literal { int: 1 } } } } }, pointmap: "Identfallback" } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 06935d3f66ec6143b45cdd155c715fd441e48b2b9b96c6ee6b94f29b7c9de1c6 # shrinks to expr = SimStage { stage: "Id779", players: Runtime { runtime: PlayersOut }, end_condition: UntilRep { reps: Repititions { times: Aggregate { aggregate: SumOfCardSet { card_set: Memory { memory: WithOwner { memory: "Id663", owner: Player { player: Query { query: CollectionAt { players: Literal { players: [Literal { name: "Id100" }, Literal { name: "Identfallback" }] }, int: Literal { int: 1 } } } } } }, pointmap: "Identfallback" } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc a7c6b188bbc4fe95ba1c3e920d68ac0b8907ac80d69302b591c09f77c1e05d28 # shrinks to expr = Action { action: BidAction { quantitiy: IntRange { int_range: IntRange { start: (Gt, Aggregate { aggregate: SumOfIntCollection { int_collection: Memory { memory: WithOwner { memory: "Id349", owner: Player { player: Query { query: CollectionAt { players: Memory { memory: Memory { memory: "Id100" } }, int: Literal { int: 1 } } } } } } } }), op_int: [(And, Eq, Literal { int: 1 })] } } } }
cc ff7d7ba84ed48ccd60a419d5f590eb876708e3461030e4486e0be2e445f90a22 # shrinks to expr = Conditional { cases: [NoBool { flows: [Rule { game_rule: Action { action: FlipAction { card_set: Group { group: Where { groupable: LocationCollection { location_collection: Memory { memory: WithOwner { memory: "Id180", owner: Player { player: Query { query: CollectionAt { players: Memory { memory: Memory { memory: "Id100" } }, int: Literal { int: 1 } } } } } } }, filter: Aggregate { aggregate: Combo { combo: "BASECASE" } } } }, status: FaceUp } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }, NoBool { flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }] }
cc d754176ce220617ff4bb6384e7993622d49a4b261a2ce3aea7dae5137ee3c8a6 # shrinks to expr = IfRule { condition: Aggregate { aggregate: CardSetNotEmpty { card_set: Group { group: CardPosition { card_position: Aggregate { aggregate: ExtremaPointMap { extrema: Min, card_set: Memory { memory: WithOwner { memory: "Id692", owner: Player { player: Query { query: CollectionAt { players: Memory { memory: Memory { memory: "Id100" } }, int: Literal { int: 1 } } } } } }, pointmap: "Identfallback" } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc ef4b9b2c08fa3c49741190f21772589315d6bc2f4d19dfb9b07ac01d5b2f2a87 # shrinks to expr = SimStage { stage: "Id855", players: Aggregate { aggregate: Quantifier { quantifier: All } }, end_condition: UntilBool { bool_expr: Aggregate { aggregate: StringNotInCardSet { string: Literal { value: "Id862" }, card_set: GroupOwner { group: Groupable { groupable: Location { name: "Defaultloc" } }, owner: Player { player: Query { query: CollectionAt { players: Memory { memory: Memory { memory: "Id100" } }, int: Literal { int: 1 } } } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc ed1400ed9db298593a3e5c36456e72f31c71c5fb3b52811a03d2d3c232dda2e8 # shrinks to expr = Conditional { cases: [Bool { bool_expr: Aggregate { aggregate: Compare { cmp_bool: CardSet { card_set: Group { group: Where { groupable: LocationCollection { location_collection: Literal { locations: ["Id540", "Id421"] } }, filter: Aggregate { aggregate: Combo { combo: "BASECASE" } } } }, cmp: Eq, card_set1: Memory { memory: Memory { memory: "Identfallback" } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }] }
cc 36981d3cc5a72f1b3bf9e0ca2b78612732a992f6721374b863b7bfdcfc6bf06c # shrinks to expr = Conditional { cases: [NoBool { flows: [Rule { game_rule: SetUp { setup: CreateCombo { combo: "Id863", filter: Binary { filter: Aggregate { aggregate: Lower { key: "Id874", value: Memory { memory: Memory { memory: "Id100" } }, precedence: "Identfallback" } }, op: And, filter1: Aggregate { aggregate: Combo { combo: "BASECASE" } } } } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }] }
cc 08f7bd4fc0135b6def9885b4ecd4461cba9bff0ba02ef092b9fec47283b1202b # shrinks to expr = Conditional { cases: [Bool { bool_expr: Aggregate { aggregate: CardSetEmpty { card_set: Group { group: Where { groupable: LocationCollection { location_collection: Literal { locations: ["Id180"] } }, filter: Binary { filter: Aggregate { aggregate: KeyIsNotString { key: "Id849", string: Query { query: StringCollectionAt { string_collection: Memory { memory: Memory { memory: "Id100" } }, int_expr: Literal { int: 1 } } } } }, op: And, filter1: Aggregate { aggregate: Combo { combo: "BASECASE" } } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }] }
cc 41650cec5f61ffb65dc03a719997a358d5723001ab9dcea224da57708259ede5 # shrinks to expr = SetUp { setup: CreateCombo { combo: "Id407", filter: Aggregate { aggregate: KeyIsNotString { key: "Id356", string: Literal { value: "Id100" } } } } }
cc d1eeeea6c26bbc96ce7be16c8c98744649795445fc62a47357cfcce1b6e55a64 # shrinks to expr = IfRule { condition: Unary { op: Not, bool_expr: Aggregate { aggregate: CardSetEmpty { card_set: GroupOwner { group: Where { groupable: LocationCollection { location_collection: Literal { locations: ["Id727"] } }, filter: Aggregate { aggregate: KeyIsNotString { key: "Id419", string: Query { query: KeyOf { key: "Id100", card_position: Query { query: Top { location: "Deck" } } } } } } }, owner: Player { player: Literal { name: "Identfallback" } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc fa60d89f7d2319c14bcf4ffffddd35d563b674e5540c30bc8f53506f7ea564f9 # shrinks to expr = IfRule { condition: Unary { op: Not, bool_expr: Binary { bool_expr: Aggregate { aggregate: CardSetNotEmpty { card_set: GroupOwner { group: Groupable { groupable: LocationCollection { location_collection: Literal { locations: ["Id814"] } } }, owner: TeamCollection { team_collection: Memory { memory: Memory { memory: "Id100" } } } } } }, op: And, bool_expr1: Aggregate { aggregate: CardSetEmpty { card_set: Group { group: Groupable { groupable: Location { name: "BASECASE" } } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 1ab1492708a73d463a4bef78d6f07919c20ee9e6749caf1321d9ee3ea807cf9e # shrinks to expr = SimStage { stage: "Id860", players: Runtime { runtime: Others }, end_condition: UntilBool { bool_expr: Aggregate { aggregate: Compare { cmp_bool: Int { int: Aggregate { aggregate: SumOfIntCollection { int_collection: Literal { ints: [Runtime { runtime: PlayRoundCounter }] } } }, cmp: Neq, int1: Query { query: IntCollectionAt { int_collection: Literal { ints: [Aggregate { aggregate: SizeOf { collection: TeamCollection { team: Runtime { runtime: OtherTeams } } } }, Aggregate { aggregate: ExtremaCardset { extrema: Max, card_set: GroupOwner { group: Groupable { groupable: Location { name: "Defaultloc" } }, owner: TeamCollection { team_collection: Memory { memory: Memory { memory: "Id100" } } } }, pointmap: "Identfallback" } }, Literal { int: 1 }] }, int_expr: Literal { int: 1 } } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc abb621b6a7d3c1576123242d3720cf8f9183aca5e5b4a1c4c094d952697e0fc3 # shrinks to expr = Game { flows: [Rule { game_rule: Action { action: PlayerOutOfGameSuccAction { players: Player { player: Memory { memory: Memory { memory: "Id242" } } } } } }, Rule { game_rule: Scoring { scoring: WinnerRule { winner_rule: Winner { players: Player { player: Query { query: CollectionAt { players: Literal { players: [Memory { memory: Memory { memory: "Id100" } }] }, int: Literal { int: 1 } } } } } } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 8bcae15dca1e695f98aba8dae8522d92a672221a81ebd0d886cbf82eaab97ad7 # shrinks to expr = SetUp { setup: CreateMemory { memory: "Id373", owner: Player { player: Query { query: CollectionAt { players: Literal { players: [Memory { memory: Memory { memory: "Id100" } }] }, int: Literal { int: 1 } } } } } }
cc f1ddd5c0c31178c61b59e0178e64bc26356cfd75c930a67aed7decc8d40e5352 # shrinks to expr = SimStage { stage: "Id166", players: Literal { players: [Query { query: CollectionAt { players: Literal { players: [Memory { memory: Memory { memory: "Id100" } }] }, int: Literal { int: 1 } } }, Literal { name: "Identfallback" }, Literal { name: "Identfallback" }] }, end_condition: UntilBool { bool_expr: Aggregate { aggregate: CardSetEmpty { card_set: Group { group: Groupable { groupable: Location { name: "BASECASE" } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 9f67428127d1ec45a54a56ec35ebf908d31d663aa7c9fac206f914d14b7dfc19 # shrinks to expr = IfRule { condition: Aggregate { aggregate: OutOfPlayer { players: Player { player: Query { query: CollectionAt { players: Literal { players: [Memory { memory: Memory { memory: "Id286" } }] }, int: Literal { int: 1 } } } }, out_of: CurrentStage } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc efe73129860a57a1cc08d15543a909e4067f9a0032b31b92e1291fd4bd549dae # shrinks to expr = ChoiceRule { options: [Rule { game_rule: Action { action: PlayerOutOfStageAction { players: PlayerCollection { player_collection: Literal { players: [Query { query: CollectionAt { players: Literal { players: [Memory { memory: Memory { memory: "Id102" } }] }, int: Literal { int: 1 } } }] } } } } }] }
cc 8f992ed0050f552e6a72dd4893b77f30d1994bcdb6fce87c2a95070b3a2a0878 # shrinks to expr = Conditional { cases: [Bool { bool_expr: Aggregate { aggregate: OutOfPlayer { players: PlayerCollection { player_collection: Literal { players: [Literal { name: "Id684" }, Query { query: CollectionAt { players: Literal { players: [Query { query: CollectionAt { players: Literal { players: [Memory { memory: Memory { memory: "Id100" } }] }, int: Literal { int: 1 } } }, Literal { name: "Identfallback" }] }, int: Literal { int: 1 } } }] } }, out_of: CurrentStage } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }, NoBool { flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }] }
cc 787f6c19274fe8470c26e9ad8309b5914657c9b16b997e68ba57f63e4ababb05 # shrinks to expr = ChoiceRule { options: [Rule { game_rule: Scoring { scoring: ScoreRule { score_rule: ScoreMemory { int: Query { query: IntCollectionAt { int_collection: Memory { memory: WithOwner { memory: "Id437", owner: TeamCollection { team_collection: Literal { teams: [Memory { memory: WithOwner { memory: "Id118", owner: PlayerCollection { player_collection: Runtime { runtime: PlayersIn } } } }, Literal { name: "Identfallback" }, Literal { name: "Identfallback" }] } } } }, int_expr: Literal { int: 1 } } }, memory: "Identfallback", players: Player { player: Literal { name: "Identfallback" } } } } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc bcb21f6dd9dede4ee59dc37a0db737a6ef841a45a86c903941fb1dd82fc8cafc # shrinks to expr = Conditional { cases: [NoBool { flows: [Rule { game_rule: Action { action: ShuffleAction { card_set: Memory { memory: WithOwner { memory: "Id259", owner: TeamCollection { team_collection: Literal { teams: [Memory { memory: WithOwner { memory: "Id768", owner: PlayerCollection { player_collection: Runtime { runtime: PlayersIn } } } }, Literal { name: "Identfallback" }] } } } } } } }] }] }
cc e6f3805167971635c2626f646fb56fd7b81c28ada0ccf16a507c4607895d8dc8 # shrinks to expr = Game { flows: [Rule { game_rule: Action { action: ShuffleAction { card_set: Group { group: Where { groupable: LocationCollection { location_collection: Memory { memory: WithOwner { memory: "Id178", owner: TeamCollection { team_collection: Literal { teams: [Memory { memory: WithOwner { memory: "Id710", owner: TeamCollection { team_collection: Runtime { runtime: OtherTeams } } } }, Literal { name: "Identfallback" }, Literal { name: "Identfallback" }] } } } } }, filter: Aggregate { aggregate: Combo { combo: "BASECASE" } } } } } } }] }
cc d76ce2863c42d7aa31fa91b68b819fa1dd3eacc5852efc51902059ce4f710484 # shrinks to expr = IfRule { condition: Aggregate { aggregate: Compare { cmp_bool: Team { team: Memory { memory: WithOwner { memory: "Id328", owner: PlayerCollection { player_collection: Runtime { runtime: PlayersIn } } } }, cmp: Eq, team1: Literal { name: "Id100" } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 244dbad6412e4dbdd5d9592412c8553385e568d60cc7e1e28ca8284c2c05b6a1 # shrinks to expr = SimStage { stage: "Id911", players: Aggregate { aggregate: Quantifier { quantifier: Any } }, end_condition: UntilRep { reps: Repititions { times: Binary { int: Aggregate { aggregate: SizeOf { collection: TeamCollection { team: Literal { teams: [Memory { memory: WithOwner { memory: "Id161", owner: PlayerCollection { player_collection: Runtime { runtime: PlayersIn } } } }] } } } }, op: Plus, int1: Literal { int: 1 } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 884915026373a131b59d0783c8b0230c1594e4aa4c7ea3aef719bfb49599ac58 # shrinks to expr = ChoiceRule { options: [Rule { game_rule: SetUp { setup: CreateTurnorder { player_collection: AggregateMemory { memory: "Id354", multi: TeamCollection { team_collection: AggregateMemory { memory: "Id100", multi: PlayerCollection { player_collection: Runtime { runtime: PlayersIn } } } } } } } }] }
cc 0e86ec9cf2510882028d7b4877ca9329bea5ffe92cb9d895982207d7c2b86ef7 # shrinks to expr = Game { flows: [Rule { game_rule: SetUp { setup: CreateMemoryWithMemoryType { memory: "Id600", memory_type: TeamCollection { teams: AggregateMemory { memory: "Id100", multi: PlayerCollection { player_collection: Runtime { runtime: PlayersIn } } } }, owner: Player { player: Literal { name: "Identfallback" } } } } }, Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 237b056412401ed5738c2a50eab1285be593d8679d1a2d733bf882cfb2dd27d3 # shrinks to expr = SimStage { stage: "Id199", players: AggregateMemory { memory: "Id435", multi: TeamCollection { team_collection: AggregateMemory { memory: "Id100", multi: PlayerCollection { player_collection: Runtime { runtime: PlayersIn } } } } }, end_condition: UntilBool { bool_expr: Aggregate { aggregate: CardSetEmpty { card_set: Group { group: Groupable { groupable: Location { name: "BASECASE" } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 11164bcbe79cd37c6ee8f9d8a4c7d3a3224312784e83f5aea623cc6f602a1284 # shrinks to expr = SeqStage { stage: "Id382", player: Runtime { runtime: Competitor }, end_condition: UntilRep { reps: Repititions { times: Aggregate { aggregate: ExtremaIntCollection { extrema: Max, int_collection: Memory { memory: WithOwner { memory: "Id608", owner: TeamCollection { team_collection: AggregateMemory { memory: "Id100", multi: PlayerCollection { player_collection: Runtime { runtime: PlayersIn } } } } } } } } } }, flows: [Rule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
cc 5d613c15b0bbc086cf90ef5d30f68dcbd86029ec679ba5a94926b794aa17bcab # shrinks to expr = OptionalRule { flows: [GameRule { game_rule: Scoring { scoring: ScoreRule { score_rule: Score { int: Aggregate { aggregate: ExtremaCardset { extrema: Max, card_set: GroupOwner { group: Where { groupable: LocationCollection { location_collection: Literal { locations: ["Id286"] } }, filter: Aggregate { aggregate: Size { cmp: Gt, int_expr: Runtime { runtime: CurrentStageRoundCounter } } } }, owner: Player { player: Literal { name: "Id984" } } }, pointmap: "Id100" } }, players: Player { player: Literal { name: "Identfallback" } } } } } }, GameRule { game_rule: Action { action: EndAction { end_type: Turn } } }] }
