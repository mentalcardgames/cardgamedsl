   Compiling proc-macro2 v1.0.106
    Checking once_cell v1.21.3
    Checking quote v1.0.44
   Compiling syn v2.0.115
   Compiling syn v1.0.109
   Compiling pest_generator v2.8.6
   Compiling pest_consume_macros v1.1.0
   Compiling serde_derive v1.0.228
   Compiling pest_derive v2.8.6
   Compiling code_gen v0.1.0 (/home/till/BachelorProject/CardGameDSL/code_gen)
    Checking pest_consume v1.1.3
    Checking serde v1.0.228
    Checking ron v0.12.0
    Checking bincode v1.3.3
    Checking front_end v0.1.0 (/home/till/BachelorProject/CardGameDSL/front_end)
Total items found in module: 81
pub mod ast
{
    use serde :: { Serialize, Deserialize };
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum BinCompare
    { Eq, Neq, } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
    LogicBinOp { And, Or, } #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum IntOp { Plus, Minus, Mul, Div, Mod, }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum IntCompare
    { Eq, Neq, Gt, Lt, Ge, Le, }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum Extrema
    { Min, Max, } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
    OutOf { CurrentStage, Stage(String), Game, Play, }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum Groupable
    { Location(String), LocationCollection(LocationCollection), }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum Owner
    {
        Player(PlayerExpr), PlayerCollection(PlayerCollection),
        Team(TeamExpr), TeamCollection(TeamCollection), Table,
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum Quantity
    { Int(IntExpr), Quantifier(Quantifier), IntRange(IntRange), }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub struct IntRange
    { pub op_int : Vec < (IntCompare, IntExpr) > , }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum Quantifier
    { All, Any, } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
    EndCondition
    {
        UntilBool(BoolExpr), UntilBoolRep(BoolExpr, LogicBinOp, Repititions),
        UntilRep(Repititions), UntilEnd,
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub struct Repititions
    { pub times : IntExpr, } #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum MemoryType
    {
        Int(IntExpr), String(StringExpr), CardSet(CardSet),
        Collection(Collection),
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum Players
    { Player(PlayerExpr), PlayerCollection(PlayerCollection), }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum EndType
    { Turn, Stage, GameWithWinner(Players), }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum DemandType
    { CardPosition(CardPosition), String(StringExpr), Int(IntExpr), }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub struct Types
    { pub types : Vec < (String, Vec < String >) > , }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum RuntimePlayer
    { Current, Next, Previous, Competitor, }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum QueryPlayer
    { Turnorder(IntExpr), } #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum AggregatePlayer
    {
        OwnerOfCardPostion(Box < CardPosition >),
        OwnerOfMemory(Extrema, String),
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum PlayerExpr
    {
        Literal(String), Runtime(RuntimePlayer), Aggregate(AggregatePlayer),
        Query(QueryPlayer),
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum QueryInt
    { IntCollectionAt(Box < IntCollection > , Box < IntExpr >), }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum AggregateInt
    {
        SizeOf(Collection), SumOfIntCollection(IntCollection),
        SumOfCardSet(Box < CardSet > , String),
        ExtremaCardset(Extrema, Box < CardSet > , String),
        ExtremaIntCollection(Extrema, IntCollection),
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum RuntimeInt
    { StageRoundCounter, PlayRoundCounter, }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum IntExpr
    {
        Literal(i32), Binary(Box < IntExpr > , IntOp, Box < IntExpr >),
        Query(QueryInt), Aggregate(AggregateInt), Runtime(RuntimeInt),
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum QueryString
    {
        KeyOf(String, CardPosition),
        StringCollectionAt(StringCollection, IntExpr),
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum StringExpr
    { Literal(String), Query(QueryString), } pub type SCardSetCompare =
    Spanned < CardSetCompare > ;
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum CardSetCompare
    { Eq, Neq, } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
    StringCompare { Eq, Neq, } #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum PlayerCompare { Eq, Neq, }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum TeamCompare
    { Eq, Neq, } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
    BoolOp { And, Or, } #[derive(Debug, Clone, Serialize, Deserialize)] pub
    enum UnaryOp { Not, } #[derive(Debug, Clone, Serialize, Deserialize)] pub
    enum CompareBool
    {
        Int(IntExpr, IntCompare, IntExpr),
        CardSet(CardSet, CardSetCompare, CardSet),
        String(StringExpr, StringCompare, StringExpr),
        Player(PlayerExpr, PlayerCompare, PlayerExpr),
        Team(TeamExpr, TeamCompare, TeamExpr),
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum AggregateBool
    {
        Compare(CompareBool), CardSetEmpty(CardSet), CardSetNotEmpty(CardSet),
        OutOfPlayer(Players, OutOf),
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum BoolExpr
    {
        Binary(Box < BoolExpr > , BoolOp, Box < BoolExpr >),
        Unary(UnaryOp, Box < BoolExpr >), Aggregate(AggregateBool),
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum AggregateTeam
    { TeamOf(PlayerExpr), } #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum TeamExpr { Literal(String), Aggregate(AggregateTeam), }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum QueryCardPosition
    { At(String, IntExpr), Top(String), Bottom(String), }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
    AggregateCardPosition
    {
        ExtremaPointMap(Extrema, Box < CardSet > , String),
        ExtremaPrecedence(Extrema, Box < CardSet > , String),
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum CardPosition
    { Query(QueryCardPosition), Aggregate(AggregateCardPosition), }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum Status
    { FaceUp, FaceDown, Private, }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum Collection
    {
        IntCollection(IntCollection), StringCollection(StringCollection),
        LocationCollection(LocationCollection),
        PlayerCollection(PlayerCollection), TeamCollection(TeamCollection),
        CardSet(Box < CardSet >),
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub struct IntCollection
    { pub ints : Vec < IntExpr > , }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub struct
    StringCollection { pub strings : Vec < StringExpr > , }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub struct
    LocationCollection { pub locations : Vec < String > , }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
    RuntimePlayerCollection { PlayersOut, PlayersIn, Others, }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
    AggregatePlayerCollection { Quantifier(Quantifier), }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum PlayerCollection
    {
        Literal(Vec < PlayerExpr >), Aggregate(AggregatePlayerCollection),
        Runtime(RuntimePlayerCollection),
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
    RuntimeTeamCollection { OtherTeams, }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum TeamCollection
    { Literal(Vec < TeamExpr >), Runtime(RuntimeTeamCollection), }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum CardSet
    { Group(Group), GroupOwner(Group, Owner), }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum Group
    {
        Groupable(Groupable), Where(Groupable, FilterExpr),
        NotCombo(String, Groupable), Combo(String, Groupable),
        CardPosition(CardPosition),
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum AggregateFilter
    {
        Size(IntCompare, Box < IntExpr >), Same(String), Distinct(String),
        Adjacent(String, String), Higher(String, String),
        Lower(String, String),
        KeyString(String, StringCompare, Box < StringExpr >), Combo(String),
        NotCombo(String),
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum FilterOp
    { And, Or, } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
    FilterExpr
    {
        Aggregate(AggregateFilter),
        Binary(Box < FilterExpr > , FilterOp, Box < FilterExpr >),
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub struct Game
    { pub flows : Vec < FlowComponent > , }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum FlowComponent
    {
        Stage(SeqStage), Rule(GameRule), IfRule(IfRule),
        ChoiceRule(ChoiceRule), OptionalRule(OptionalRule),
        Conditional(Conditional),
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum SetUpRule
    {
        CreatePlayer(Vec < String >),
        CreateTeams(Vec < (String, PlayerCollection) >),
        CreateTurnorder(PlayerCollection),
        CreateTurnorderRandom(PlayerCollection),
        CreateLocation(Vec < String > , Owner),
        CreateCardOnLocation(String, Types),
        CreateTokenOnLocation(IntExpr, String, String),
        CreateCombo(String, FilterExpr),
        CreateMemoryWithMemoryType(String, MemoryType, Owner),
        CreateMemory(String, Owner),
        CreatePrecedence(String, Vec < (String, String) >),
        CreatePointMap(String, Vec < (String, String, IntExpr) >),
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum ActionRule
    {
        FlipAction(CardSet, Status), ShuffleAction(CardSet),
        PlayerOutOfStageAction(Players), PlayerOutOfGameSuccAction(Players),
        PlayerOutOfGameFailAction(Players), SetMemory(String, MemoryType),
        ResetMemory(String), CycleAction(PlayerExpr), BidAction(Quantity),
        BidMemoryAction(String, Quantity), EndAction(EndType),
        DemandAction(DemandType), DemandMemoryAction(DemandType, String),
        Move(MoveType),
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum ScoringRule
    { ScoreRule(ScoreRule), WinnerRule(WinnerRule), }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum GameRule
    { SetUp(SetUpRule), Action(ActionRule), Scoring(ScoringRule), }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub struct SeqStage
    {
        pub stage : String, pub player : PlayerExpr, pub end_condition :
        EndCondition, pub flows : Vec < FlowComponent > ,
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum Case
    {
        Else(Vec < FlowComponent >), NoBool(Vec < FlowComponent >),
        Bool(BoolExpr, Vec < FlowComponent >),
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub struct Conditional
    { pub cases : Vec < Case > , }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub struct IfRule
    { pub condition : BoolExpr, pub flows : Vec < FlowComponent > , }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub struct OptionalRule
    { pub flows : Vec < FlowComponent > , }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub struct ChoiceRule
    { pub options : Vec < FlowComponent > , }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum MoveType
    {
        Deal(DealMove), Exchange(ExchangeMove), Classic(ClassicMove),
        Place(TokenMove),
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum MoveCardSet
    {
        Move(CardSet, Status, CardSet),
        MoveQuantity(Quantity, CardSet, Status, CardSet),
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum ClassicMove
    { MoveCardSet(MoveCardSet), }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum DealMove
    { MoveCardSet(MoveCardSet), }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum ExchangeMove
    { MoveCardSet(MoveCardSet), }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum TokenMove
    {
        Place(String, TokenLocExpr, TokenLocExpr),
        PlaceQuantity(Quantity, String, TokenLocExpr, TokenLocExpr),
    } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum TokenLocExpr
    { Groupable(Groupable), GroupablePlayers(Groupable, Players), }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum ScoreRule
    { Score(IntExpr, Players), ScoreMemory(IntExpr, String, Players), }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum WinnerType
    { Score, Memory(String), Position, }
    #[derive(Debug, Clone, Serialize, Deserialize)] pub enum WinnerRule
    { Winner(Players), WinnerWith(Extrema, WinnerType), } pub mod ast_spanned
    {
        use super :: * ; use crate ::
        { spans :: * , lower :: * , walker :: * };
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum BinCompare
        { Eq, Neq, } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
        LogicBinOp { And, Or, }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum IntOp
        { Plus, Minus, Mul, Div, Mod, }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum IntCompare
        { Eq, Neq, Gt, Lt, Ge, Le, }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum Extrema
        { Min, Max, } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
        OutOf { CurrentStage, Stage(Spanned < String >), Game, Play, }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum Groupable
        {
            Location(Spanned < String >),
            LocationCollection(Spanned < LocationCollection >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum Owner
        {
            Player(Spanned < PlayerExpr >),
            PlayerCollection(Spanned < PlayerCollection >),
            Team(Spanned < TeamExpr >),
            TeamCollection(Spanned < TeamCollection >), Table,
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum Quantity
        {
            Int(Spanned < IntExpr >), Quantifier(Spanned < Quantifier >),
            IntRange(Spanned < IntRange >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub struct IntRange
        { pub op_int : Spanned < Vec < (IntCompare, IntExpr) > > , }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum Quantifier
        { All, Any, } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
        EndCondition
        {
            UntilBool(Spanned < BoolExpr >),
            UntilBoolRep(Spanned < BoolExpr > , Spanned < LogicBinOp > ,
            Spanned < Repititions >), UntilRep(Spanned < Repititions >),
            UntilEnd,
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub struct
        Repititions { pub times : Spanned < IntExpr > , }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum MemoryType
        {
            Int(Spanned < IntExpr >), String(Spanned < StringExpr >),
            CardSet(Spanned < CardSet >), Collection(Spanned < Collection >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum Players
        {
            Player(Spanned < PlayerExpr >),
            PlayerCollection(Spanned < PlayerCollection >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum EndType
        { Turn, Stage, GameWithWinner(Spanned < Players >), }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum DemandType
        {
            CardPosition(Spanned < CardPosition >),
            String(Spanned < StringExpr >), Int(Spanned < IntExpr >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub struct Types
        { pub types : Spanned < Vec < (String, Vec < String >) > > , }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum RuntimePlayer
        { Current, Next, Previous, Competitor, }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum QueryPlayer
        { Turnorder(Spanned < IntExpr >), }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
        AggregatePlayer
        {
            OwnerOfCardPostion(Spanned < Box < CardPosition > >),
            OwnerOfMemory(Spanned < Extrema > , Spanned < String >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum PlayerExpr
        {
            Literal(Spanned < String >), Runtime(Spanned < RuntimePlayer >),
            Aggregate(Spanned < AggregatePlayer >),
            Query(Spanned < QueryPlayer >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum QueryInt
        {
            IntCollectionAt(Spanned < Box < IntCollection > > , Spanned < Box
            < IntExpr > >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
        AggregateInt
        {
            SizeOf(Spanned < Collection >),
            SumOfIntCollection(Spanned < IntCollection >),
            SumOfCardSet(Spanned < Box < CardSet > > , Spanned < String >),
            ExtremaCardset(Spanned < Extrema > , Spanned < Box < CardSet > > ,
            Spanned < String >),
            ExtremaIntCollection(Spanned < Extrema > , Spanned < IntCollection
            >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum RuntimeInt
        { StageRoundCounter, PlayRoundCounter, }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum IntExpr
        {
            Literal(Spanned < i32 >),
            Binary(Spanned < Box < IntExpr > > , Spanned < IntOp > , Spanned <
            Box < IntExpr > >), Query(Spanned < QueryInt >),
            Aggregate(Spanned < AggregateInt >),
            Runtime(Spanned < RuntimeInt >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum QueryString
        {
            KeyOf(Spanned < String > , Spanned < CardPosition >),
            StringCollectionAt(Spanned < StringCollection > , Spanned <
            IntExpr >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum StringExpr
        { Literal(Spanned < String >), Query(Spanned < QueryString >), }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
        CardSetCompare { Eq, Neq, }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum StringCompare
        { Eq, Neq, } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
        PlayerCompare { Eq, Neq, }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum TeamCompare
        { Eq, Neq, } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
        BoolOp { And, Or, } #[derive(Debug, Clone, Serialize, Deserialize)]
        pub enum UnaryOp { Not, }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum CompareBool
        {
            Int(Spanned < IntExpr > , Spanned < IntCompare > , Spanned <
            IntExpr >),
            CardSet(Spanned < CardSet > , Spanned < CardSetCompare > , Spanned
            < CardSet >),
            String(Spanned < StringExpr > , Spanned < StringCompare > ,
            Spanned < StringExpr >),
            Player(Spanned < PlayerExpr > , Spanned < PlayerCompare > ,
            Spanned < PlayerExpr >),
            Team(Spanned < TeamExpr > , Spanned < TeamCompare > , Spanned <
            TeamExpr >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
        AggregateBool
        {
            Compare(Spanned < CompareBool >),
            CardSetEmpty(Spanned < CardSet >),
            CardSetNotEmpty(Spanned < CardSet >),
            OutOfPlayer(Spanned < Players > , Spanned < OutOf >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum BoolExpr
        {
            Binary(Spanned < Box < BoolExpr > > , Spanned < BoolOp > , Spanned
            < Box < BoolExpr > >),
            Unary(Spanned < UnaryOp > , Spanned < Box < BoolExpr > >),
            Aggregate(Spanned < AggregateBool >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
        AggregateTeam { TeamOf(Spanned < PlayerExpr >), }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum TeamExpr
        { Literal(Spanned < String >), Aggregate(Spanned < AggregateTeam >), }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
        QueryCardPosition
        {
            At(Spanned < String > , Spanned < IntExpr >),
            Top(Spanned < String >), Bottom(Spanned < String >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
        AggregateCardPosition
        {
            ExtremaPointMap(Spanned < Extrema > , Spanned < Box < CardSet > >
            , Spanned < String >),
            ExtremaPrecedence(Spanned < Extrema > , Spanned < Box < CardSet >
            > , Spanned < String >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
        CardPosition
        {
            Query(Spanned < QueryCardPosition >),
            Aggregate(Spanned < AggregateCardPosition >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum Status
        { FaceUp, FaceDown, Private, }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum Collection
        {
            IntCollection(Spanned < IntCollection >),
            StringCollection(Spanned < StringCollection >),
            LocationCollection(Spanned < LocationCollection >),
            PlayerCollection(Spanned < PlayerCollection >),
            TeamCollection(Spanned < TeamCollection >),
            CardSet(Spanned < Box < CardSet > >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub struct
        IntCollection { pub ints : Spanned < Vec < IntExpr > > , }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub struct
        StringCollection { pub strings : Spanned < Vec < StringExpr > > , }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub struct
        LocationCollection { pub locations : Spanned < Vec < String > > , }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
        RuntimePlayerCollection { PlayersOut, PlayersIn, Others, }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
        AggregatePlayerCollection { Quantifier(Spanned < Quantifier >), }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
        PlayerCollection
        {
            Literal(Spanned < Vec < PlayerExpr > >),
            Aggregate(Spanned < AggregatePlayerCollection >),
            Runtime(Spanned < RuntimePlayerCollection >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
        RuntimeTeamCollection { OtherTeams, }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
        TeamCollection
        {
            Literal(Spanned < Vec < TeamExpr > >),
            Runtime(Spanned < RuntimeTeamCollection >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum CardSet
        {
            Group(Spanned < Group >),
            GroupOwner(Spanned < Group > , Spanned < Owner >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum Group
        {
            Groupable(Spanned < Groupable >),
            Where(Spanned < Groupable > , Spanned < FilterExpr >),
            NotCombo(Spanned < String > , Spanned < Groupable >),
            Combo(Spanned < String > , Spanned < Groupable >),
            CardPosition(Spanned < CardPosition >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
        AggregateFilter
        {
            Size(Spanned < IntCompare > , Spanned < Box < IntExpr > >),
            Same(Spanned < String >), Distinct(Spanned < String >),
            Adjacent(Spanned < String > , Spanned < String >),
            Higher(Spanned < String > , Spanned < String >),
            Lower(Spanned < String > , Spanned < String >),
            KeyString(Spanned < String > , Spanned < StringCompare > , Spanned
            < Box < StringExpr > >), Combo(Spanned < String >),
            NotCombo(Spanned < String >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum FilterOp
        { And, Or, } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
        FilterExpr
        {
            Aggregate(Spanned < AggregateFilter >),
            Binary(Spanned < Box < FilterExpr > > , Spanned < FilterOp > ,
            Spanned < Box < FilterExpr > >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub struct Game
        { pub flows : Spanned < Vec < FlowComponent > > , }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum FlowComponent
        {
            Stage(Spanned < SeqStage >), Rule(Spanned < GameRule >),
            IfRule(Spanned < IfRule >), ChoiceRule(Spanned < ChoiceRule >),
            OptionalRule(Spanned < OptionalRule >),
            Conditional(Spanned < Conditional >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum SetUpRule
        {
            CreatePlayer(Spanned < Vec < String > >),
            CreateTeams(Spanned < Vec < (String, PlayerCollection) > >),
            CreateTurnorder(Spanned < PlayerCollection >),
            CreateTurnorderRandom(Spanned < PlayerCollection >),
            CreateLocation(Spanned < Vec < String > > , Spanned < Owner >),
            CreateCardOnLocation(Spanned < String > , Spanned < Types >),
            CreateTokenOnLocation(Spanned < IntExpr > , Spanned < String > ,
            Spanned < String >),
            CreateCombo(Spanned < String > , Spanned < FilterExpr >),
            CreateMemoryWithMemoryType(Spanned < String > , Spanned <
            MemoryType > , Spanned < Owner >),
            CreateMemory(Spanned < String > , Spanned < Owner >),
            CreatePrecedence(Spanned < String > , Spanned < Vec <
            (String, String) > >),
            CreatePointMap(Spanned < String > , Spanned < Vec <
            (String, String, IntExpr) > >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum ActionRule
        {
            FlipAction(Spanned < CardSet > , Spanned < Status >),
            ShuffleAction(Spanned < CardSet >),
            PlayerOutOfStageAction(Spanned < Players >),
            PlayerOutOfGameSuccAction(Spanned < Players >),
            PlayerOutOfGameFailAction(Spanned < Players >),
            SetMemory(Spanned < String > , Spanned < MemoryType >),
            ResetMemory(Spanned < String >),
            CycleAction(Spanned < PlayerExpr >),
            BidAction(Spanned < Quantity >),
            BidMemoryAction(Spanned < String > , Spanned < Quantity >),
            EndAction(Spanned < EndType >),
            DemandAction(Spanned < DemandType >),
            DemandMemoryAction(Spanned < DemandType > , Spanned < String >),
            Move(Spanned < MoveType >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum ScoringRule
        {
            ScoreRule(Spanned < ScoreRule >),
            WinnerRule(Spanned < WinnerRule >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum GameRule
        {
            SetUp(Spanned < SetUpRule >), Action(Spanned < ActionRule >),
            Scoring(Spanned < ScoringRule >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub struct SeqStage
        {
            pub stage : Spanned < String > , pub player : Spanned < PlayerExpr
            > , pub end_condition : Spanned < EndCondition > , pub flows :
            Spanned < Vec < FlowComponent > > ,
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum Case
        {
            Else(Spanned < Vec < FlowComponent > >),
            NoBool(Spanned < Vec < FlowComponent > >),
            Bool(Spanned < BoolExpr > , Spanned < Vec < FlowComponent > >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub struct
        Conditional { pub cases : Spanned < Vec < Case > > , }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub struct IfRule
        {
            pub condition : Spanned < BoolExpr > , pub flows : Spanned < Vec <
            FlowComponent > > ,
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub struct
        OptionalRule { pub flows : Spanned < Vec < FlowComponent > > , }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub struct ChoiceRule
        { pub options : Spanned < Vec < FlowComponent > > , }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum MoveType
        {
            Deal(Spanned < DealMove >), Exchange(Spanned < ExchangeMove >),
            Classic(Spanned < ClassicMove >), Place(Spanned < TokenMove >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum MoveCardSet
        {
            Move(Spanned < CardSet > , Spanned < Status > , Spanned < CardSet
            >),
            MoveQuantity(Spanned < Quantity > , Spanned < CardSet > , Spanned
            < Status > , Spanned < CardSet >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum ClassicMove
        { MoveCardSet(Spanned < MoveCardSet >), }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum DealMove
        { MoveCardSet(Spanned < MoveCardSet >), }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum ExchangeMove
        { MoveCardSet(Spanned < MoveCardSet >), }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum TokenMove
        {
            Place(Spanned < String > , Spanned < TokenLocExpr > , Spanned <
            TokenLocExpr >),
            PlaceQuantity(Spanned < Quantity > , Spanned < String > , Spanned
            < TokenLocExpr > , Spanned < TokenLocExpr >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum
        TokenLocExpr
        {
            Groupable(Spanned < Groupable >),
            GroupablePlayers(Spanned < Groupable > , Spanned < Players >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum ScoreRule
        {
            Score(Spanned < IntExpr > , Spanned < Players >),
            ScoreMemory(Spanned < IntExpr > , Spanned < String > , Spanned <
            Players >),
        } #[derive(Debug, Clone, Serialize, Deserialize)] pub enum WinnerType
        { Score, Memory(Spanned < String >), Position, }
        #[derive(Debug, Clone, Serialize, Deserialize)] pub enum WinnerRule
        {
            Winner(Spanned < Players >),
            WinnerWith(Spanned < Extrema > , Spanned < WinnerType >),
        } pub type SBinCompare = Spanned < BinCompare > ; pub type SLogicBinOp
        = Spanned < LogicBinOp > ; pub type SIntOp = Spanned < IntOp > ; pub
        type SIntCompare = Spanned < IntCompare > ; pub type SExtrema =
        Spanned < Extrema > ; pub type SOutOf = Spanned < OutOf > ; pub type
        SGroupable = Spanned < Groupable > ; pub type SOwner = Spanned < Owner
        > ; pub type SQuantity = Spanned < Quantity > ; pub type SIntRange =
        Spanned < IntRange > ; pub type SQuantifier = Spanned < Quantifier > ;
        pub type SEndCondition = Spanned < EndCondition > ; pub type
        SRepititions = Spanned < Repititions > ; pub type SMemoryType =
        Spanned < MemoryType > ; pub type SPlayers = Spanned < Players > ; pub
        type SEndType = Spanned < EndType > ; pub type SDemandType = Spanned <
        DemandType > ; pub type STypes = Spanned < Types > ; pub type
        SRuntimePlayer = Spanned < RuntimePlayer > ; pub type SQueryPlayer =
        Spanned < QueryPlayer > ; pub type SAggregatePlayer = Spanned <
        AggregatePlayer > ; pub type SPlayerExpr = Spanned < PlayerExpr > ;
        pub type SQueryInt = Spanned < QueryInt > ; pub type SAggregateInt =
        Spanned < AggregateInt > ; pub type SRuntimeInt = Spanned < RuntimeInt
        > ; pub type SIntExpr = Spanned < IntExpr > ; pub type SQueryString =
        Spanned < QueryString > ; pub type SStringExpr = Spanned < StringExpr
        > ; pub type SCardSetCompare = Spanned < CardSetCompare > ; pub type
        SStringCompare = Spanned < StringCompare > ; pub type SPlayerCompare =
        Spanned < PlayerCompare > ; pub type STeamCompare = Spanned <
        TeamCompare > ; pub type SBoolOp = Spanned < BoolOp > ; pub type
        SUnaryOp = Spanned < UnaryOp > ; pub type SCompareBool = Spanned <
        CompareBool > ; pub type SAggregateBool = Spanned < AggregateBool > ;
        pub type SBoolExpr = Spanned < BoolExpr > ; pub type SAggregateTeam =
        Spanned < AggregateTeam > ; pub type STeamExpr = Spanned < TeamExpr >
        ; pub type SQueryCardPosition = Spanned < QueryCardPosition > ; pub
        type SAggregateCardPosition = Spanned < AggregateCardPosition > ; pub
        type SCardPosition = Spanned < CardPosition > ; pub type SStatus =
        Spanned < Status > ; pub type SCollection = Spanned < Collection > ;
        pub type SIntCollection = Spanned < IntCollection > ; pub type
        SStringCollection = Spanned < StringCollection > ; pub type
        SLocationCollection = Spanned < LocationCollection > ; pub type
        SRuntimePlayerCollection = Spanned < RuntimePlayerCollection > ; pub
        type SAggregatePlayerCollection = Spanned < AggregatePlayerCollection
        > ; pub type SPlayerCollection = Spanned < PlayerCollection > ; pub
        type SRuntimeTeamCollection = Spanned < RuntimeTeamCollection > ; pub
        type STeamCollection = Spanned < TeamCollection > ; pub type SCardSet
        = Spanned < CardSet > ; pub type SGroup = Spanned < Group > ; pub type
        SAggregateFilter = Spanned < AggregateFilter > ; pub type SFilterOp =
        Spanned < FilterOp > ; pub type SFilterExpr = Spanned < FilterExpr > ;
        pub type SGame = Spanned < Game > ; pub type SFlowComponent = Spanned
        < FlowComponent > ; pub type SSetUpRule = Spanned < SetUpRule > ; pub
        type SActionRule = Spanned < ActionRule > ; pub type SScoringRule =
        Spanned < ScoringRule > ; pub type SGameRule = Spanned < GameRule > ;
        pub type SSeqStage = Spanned < SeqStage > ; pub type SCase = Spanned <
        Case > ; pub type SConditional = Spanned < Conditional > ; pub type
        SIfRule = Spanned < IfRule > ; pub type SOptionalRule = Spanned <
        OptionalRule > ; pub type SChoiceRule = Spanned < ChoiceRule > ; pub
        type SMoveType = Spanned < MoveType > ; pub type SMoveCardSet =
        Spanned < MoveCardSet > ; pub type SClassicMove = Spanned <
        ClassicMove > ; pub type SDealMove = Spanned < DealMove > ; pub type
        SExchangeMove = Spanned < ExchangeMove > ; pub type STokenMove =
        Spanned < TokenMove > ; pub type STokenLocExpr = Spanned <
        TokenLocExpr > ; pub type SScoreRule = Spanned < ScoreRule > ; pub
        type SWinnerType = Spanned < WinnerType > ; pub type SWinnerRule =
        Spanned < WinnerRule > ; impl Lower < super :: BinCompare > for
        Spanned < BinCompare >
        {
            fn lower(& self) -> super :: BinCompare
            {
                match & self.node
                {
                    BinCompare :: Eq => super :: BinCompare :: Eq, BinCompare ::
                    Neq => super :: BinCompare :: Neq
                }
            }
        } impl Lower < super :: LogicBinOp > for Spanned < LogicBinOp >
        {
            fn lower(& self) -> super :: LogicBinOp
            {
                match & self.node
                {
                    LogicBinOp :: And => super :: LogicBinOp :: And, LogicBinOp
                    :: Or => super :: LogicBinOp :: Or
                }
            }
        } impl Lower < super :: IntOp > for Spanned < IntOp >
        {
            fn lower(& self) -> super :: IntOp
            {
                match & self.node
                {
                    IntOp :: Plus => super :: IntOp :: Plus, IntOp :: Minus =>
                    super :: IntOp :: Minus, IntOp :: Mul => super :: IntOp ::
                    Mul, IntOp :: Div => super :: IntOp :: Div, IntOp :: Mod =>
                    super :: IntOp :: Mod
                }
            }
        } impl Lower < super :: IntCompare > for Spanned < IntCompare >
        {
            fn lower(& self) -> super :: IntCompare
            {
                match & self.node
                {
                    IntCompare :: Eq => super :: IntCompare :: Eq, IntCompare ::
                    Neq => super :: IntCompare :: Neq, IntCompare :: Gt => super
                    :: IntCompare :: Gt, IntCompare :: Lt => super :: IntCompare
                    :: Lt, IntCompare :: Ge => super :: IntCompare :: Ge,
                    IntCompare :: Le => super :: IntCompare :: Le
                }
            }
        } impl Lower < super :: Extrema > for Spanned < Extrema >
        {
            fn lower(& self) -> super :: Extrema
            {
                match & self.node
                {
                    Extrema :: Min => super :: Extrema :: Min, Extrema :: Max =>
                    super :: Extrema :: Max
                }
            }
        } impl Lower < super :: OutOf > for Spanned < OutOf >
        {
            fn lower(& self) -> super :: OutOf
            {
                match & self.node
                {
                    OutOf :: CurrentStage => super :: OutOf :: CurrentStage,
                    OutOf :: Stage(f0) =>
                    { super :: OutOf :: Stage(f0.lower()) }, OutOf :: Game =>
                    super :: OutOf :: Game, OutOf :: Play => super :: OutOf ::
                    Play
                }
            }
        } impl Lower < super :: Groupable > for Spanned < Groupable >
        {
            fn lower(& self) -> super :: Groupable
            {
                match & self.node
                {
                    Groupable :: Location(f0) =>
                    { super :: Groupable :: Location(f0.lower()) }, Groupable ::
                    LocationCollection(f0) =>
                    { super :: Groupable :: LocationCollection(f0.lower()) }
                }
            }
        } impl Lower < super :: Owner > for Spanned < Owner >
        {
            fn lower(& self) -> super :: Owner
            {
                match & self.node
                {
                    Owner :: Player(f0) =>
                    { super :: Owner :: Player(f0.lower()) }, Owner ::
                    PlayerCollection(f0) =>
                    { super :: Owner :: PlayerCollection(f0.lower()) }, Owner ::
                    Team(f0) => { super :: Owner :: Team(f0.lower()) }, Owner ::
                    TeamCollection(f0) =>
                    { super :: Owner :: TeamCollection(f0.lower()) }, Owner ::
                    Table => super :: Owner :: Table
                }
            }
        } impl Lower < super :: Quantity > for Spanned < Quantity >
        {
            fn lower(& self) -> super :: Quantity
            {
                match & self.node
                {
                    Quantity :: Int(f0) =>
                    { super :: Quantity :: Int(f0.lower()) }, Quantity ::
                    Quantifier(f0) =>
                    { super :: Quantity :: Quantifier(f0.lower()) }, Quantity ::
                    IntRange(f0) =>
                    { super :: Quantity :: IntRange(f0.lower()) }
                }
            }
        } impl Lower < super :: IntRange > for Spanned < IntRange >
        {
            fn lower(& self) -> super :: IntRange
            { super :: IntRange { op_int : self.node.op_int.lower() } }
        } impl Lower < super :: Quantifier > for Spanned < Quantifier >
        {
            fn lower(& self) -> super :: Quantifier
            {
                match & self.node
                {
                    Quantifier :: All => super :: Quantifier :: All, Quantifier
                    :: Any => super :: Quantifier :: Any
                }
            }
        } impl Lower < super :: EndCondition > for Spanned < EndCondition >
        {
            fn lower(& self) -> super :: EndCondition
            {
                match & self.node
                {
                    EndCondition :: UntilBool(f0) =>
                    { super :: EndCondition :: UntilBool(f0.lower()) },
                    EndCondition :: UntilBoolRep(f0, f1, f2) =>
                    {
                        super :: EndCondition ::
                        UntilBoolRep(f0.lower(), f1.lower(), f2.lower())
                    }, EndCondition :: UntilRep(f0) =>
                    { super :: EndCondition :: UntilRep(f0.lower()) },
                    EndCondition :: UntilEnd => super :: EndCondition ::
                    UntilEnd
                }
            }
        } impl Lower < super :: Repititions > for Spanned < Repititions >
        {
            fn lower(& self) -> super :: Repititions
            { super :: Repititions { times : self.node.times.lower() } }
        } impl Lower < super :: MemoryType > for Spanned < MemoryType >
        {
            fn lower(& self) -> super :: MemoryType
            {
                match & self.node
                {
                    MemoryType :: Int(f0) =>
                    { super :: MemoryType :: Int(f0.lower()) }, MemoryType ::
                    String(f0) => { super :: MemoryType :: String(f0.lower()) },
                    MemoryType :: CardSet(f0) =>
                    { super :: MemoryType :: CardSet(f0.lower()) }, MemoryType
                    :: Collection(f0) =>
                    { super :: MemoryType :: Collection(f0.lower()) }
                }
            }
        } impl Lower < super :: Players > for Spanned < Players >
        {
            fn lower(& self) -> super :: Players
            {
                match & self.node
                {
                    Players :: Player(f0) =>
                    { super :: Players :: Player(f0.lower()) }, Players ::
                    PlayerCollection(f0) =>
                    { super :: Players :: PlayerCollection(f0.lower()) }
                }
            }
        } impl Lower < super :: EndType > for Spanned < EndType >
        {
            fn lower(& self) -> super :: EndType
            {
                match & self.node
                {
                    EndType :: Turn => super :: EndType :: Turn, EndType ::
                    Stage => super :: EndType :: Stage, EndType ::
                    GameWithWinner(f0) =>
                    { super :: EndType :: GameWithWinner(f0.lower()) }
                }
            }
        } impl Lower < super :: DemandType > for Spanned < DemandType >
        {
            fn lower(& self) -> super :: DemandType
            {
                match & self.node
                {
                    DemandType :: CardPosition(f0) =>
                    { super :: DemandType :: CardPosition(f0.lower()) },
                    DemandType :: String(f0) =>
                    { super :: DemandType :: String(f0.lower()) }, DemandType ::
                    Int(f0) => { super :: DemandType :: Int(f0.lower()) }
                }
            }
        } impl Lower < super :: Types > for Spanned < Types >
        {
            fn lower(& self) -> super :: Types
            { super :: Types { types : self.node.types.lower() } }
        } impl Lower < super :: RuntimePlayer > for Spanned < RuntimePlayer >
        {
            fn lower(& self) -> super :: RuntimePlayer
            {
                match & self.node
                {
                    RuntimePlayer :: Current => super :: RuntimePlayer ::
                    Current, RuntimePlayer :: Next => super :: RuntimePlayer ::
                    Next, RuntimePlayer :: Previous => super :: RuntimePlayer ::
                    Previous, RuntimePlayer :: Competitor => super ::
                    RuntimePlayer :: Competitor
                }
            }
        } impl Lower < super :: QueryPlayer > for Spanned < QueryPlayer >
        {
            fn lower(& self) -> super :: QueryPlayer
            {
                match & self.node
                {
                    QueryPlayer :: Turnorder(f0) =>
                    { super :: QueryPlayer :: Turnorder(f0.lower()) }
                }
            }
        } impl Lower < super :: AggregatePlayer > for Spanned <
        AggregatePlayer >
        {
            fn lower(& self) -> super :: AggregatePlayer
            {
                match & self.node
                {
                    AggregatePlayer :: OwnerOfCardPostion(f0) =>
                    {
                        super :: AggregatePlayer :: OwnerOfCardPostion(f0.lower())
                    }, AggregatePlayer :: OwnerOfMemory(f0, f1) =>
                    {
                        super :: AggregatePlayer ::
                        OwnerOfMemory(f0.lower(), f1.lower())
                    }
                }
            }
        } impl Lower < super :: PlayerExpr > for Spanned < PlayerExpr >
        {
            fn lower(& self) -> super :: PlayerExpr
            {
                match & self.node
                {
                    PlayerExpr :: Literal(f0) =>
                    { super :: PlayerExpr :: Literal(f0.lower()) }, PlayerExpr
                    :: Runtime(f0) =>
                    { super :: PlayerExpr :: Runtime(f0.lower()) }, PlayerExpr
                    :: Aggregate(f0) =>
                    { super :: PlayerExpr :: Aggregate(f0.lower()) }, PlayerExpr
                    :: Query(f0) => { super :: PlayerExpr :: Query(f0.lower()) }
                }
            }
        } impl Lower < super :: QueryInt > for Spanned < QueryInt >
        {
            fn lower(& self) -> super :: QueryInt
            {
                match & self.node
                {
                    QueryInt :: IntCollectionAt(f0, f1) =>
                    {
                        super :: QueryInt :: IntCollectionAt(f0.lower(), f1.lower())
                    }
                }
            }
        } impl Lower < super :: AggregateInt > for Spanned < AggregateInt >
        {
            fn lower(& self) -> super :: AggregateInt
            {
                match & self.node
                {
                    AggregateInt :: SizeOf(f0) =>
                    { super :: AggregateInt :: SizeOf(f0.lower()) },
                    AggregateInt :: SumOfIntCollection(f0) =>
                    { super :: AggregateInt :: SumOfIntCollection(f0.lower()) },
                    AggregateInt :: SumOfCardSet(f0, f1) =>
                    {
                        super :: AggregateInt ::
                        SumOfCardSet(f0.lower(), f1.lower())
                    }, AggregateInt :: ExtremaCardset(f0, f1, f2) =>
                    {
                        super :: AggregateInt ::
                        ExtremaCardset(f0.lower(), f1.lower(), f2.lower())
                    }, AggregateInt :: ExtremaIntCollection(f0, f1) =>
                    {
                        super :: AggregateInt ::
                        ExtremaIntCollection(f0.lower(), f1.lower())
                    }
                }
            }
        } impl Lower < super :: RuntimeInt > for Spanned < RuntimeInt >
        {
            fn lower(& self) -> super :: RuntimeInt
            {
                match & self.node
                {
                    RuntimeInt :: StageRoundCounter => super :: RuntimeInt ::
                    StageRoundCounter, RuntimeInt :: PlayRoundCounter => super
                    :: RuntimeInt :: PlayRoundCounter
                }
            }
        } impl Lower < super :: IntExpr > for Spanned < IntExpr >
        {
            fn lower(& self) -> super :: IntExpr
            {
                match & self.node
                {
                    IntExpr :: Literal(f0) =>
                    { super :: IntExpr :: Literal(f0.lower()) }, IntExpr ::
                    Binary(f0, f1, f2) =>
                    {
                        super :: IntExpr ::
                        Binary(f0.lower(), f1.lower(), f2.lower())
                    }, IntExpr :: Query(f0) =>
                    { super :: IntExpr :: Query(f0.lower()) }, IntExpr ::
                    Aggregate(f0) =>
                    { super :: IntExpr :: Aggregate(f0.lower()) }, IntExpr ::
                    Runtime(f0) => { super :: IntExpr :: Runtime(f0.lower()) }
                }
            }
        } impl Lower < super :: QueryString > for Spanned < QueryString >
        {
            fn lower(& self) -> super :: QueryString
            {
                match & self.node
                {
                    QueryString :: KeyOf(f0, f1) =>
                    { super :: QueryString :: KeyOf(f0.lower(), f1.lower()) },
                    QueryString :: StringCollectionAt(f0, f1) =>
                    {
                        super :: QueryString ::
                        StringCollectionAt(f0.lower(), f1.lower())
                    }
                }
            }
        } impl Lower < super :: StringExpr > for Spanned < StringExpr >
        {
            fn lower(& self) -> super :: StringExpr
            {
                match & self.node
                {
                    StringExpr :: Literal(f0) =>
                    { super :: StringExpr :: Literal(f0.lower()) }, StringExpr
                    :: Query(f0) => { super :: StringExpr :: Query(f0.lower()) }
                }
            }
        } impl Lower < super :: CardSetCompare > for Spanned < CardSetCompare
        >
        {
            fn lower(& self) -> super :: CardSetCompare
            {
                match & self.node
                {
                    CardSetCompare :: Eq => super :: CardSetCompare :: Eq,
                    CardSetCompare :: Neq => super :: CardSetCompare :: Neq
                }
            }
        } impl Lower < super :: StringCompare > for Spanned < StringCompare >
        {
            fn lower(& self) -> super :: StringCompare
            {
                match & self.node
                {
                    StringCompare :: Eq => super :: StringCompare :: Eq,
                    StringCompare :: Neq => super :: StringCompare :: Neq
                }
            }
        } impl Lower < super :: PlayerCompare > for Spanned < PlayerCompare >
        {
            fn lower(& self) -> super :: PlayerCompare
            {
                match & self.node
                {
                    PlayerCompare :: Eq => super :: PlayerCompare :: Eq,
                    PlayerCompare :: Neq => super :: PlayerCompare :: Neq
                }
            }
        } impl Lower < super :: TeamCompare > for Spanned < TeamCompare >
        {
            fn lower(& self) -> super :: TeamCompare
            {
                match & self.node
                {
                    TeamCompare :: Eq => super :: TeamCompare :: Eq, TeamCompare
                    :: Neq => super :: TeamCompare :: Neq
                }
            }
        } impl Lower < super :: BoolOp > for Spanned < BoolOp >
        {
            fn lower(& self) -> super :: BoolOp
            {
                match & self.node
                {
                    BoolOp :: And => super :: BoolOp :: And, BoolOp :: Or =>
                    super :: BoolOp :: Or
                }
            }
        } impl Lower < super :: UnaryOp > for Spanned < UnaryOp >
        {
            fn lower(& self) -> super :: UnaryOp
            {
                match & self.node
                { UnaryOp :: Not => super :: UnaryOp :: Not }
            }
        } impl Lower < super :: CompareBool > for Spanned < CompareBool >
        {
            fn lower(& self) -> super :: CompareBool
            {
                match & self.node
                {
                    CompareBool :: Int(f0, f1, f2) =>
                    {
                        super :: CompareBool ::
                        Int(f0.lower(), f1.lower(), f2.lower())
                    }, CompareBool :: CardSet(f0, f1, f2) =>
                    {
                        super :: CompareBool ::
                        CardSet(f0.lower(), f1.lower(), f2.lower())
                    }, CompareBool :: String(f0, f1, f2) =>
                    {
                        super :: CompareBool ::
                        String(f0.lower(), f1.lower(), f2.lower())
                    }, CompareBool :: Player(f0, f1, f2) =>
                    {
                        super :: CompareBool ::
                        Player(f0.lower(), f1.lower(), f2.lower())
                    }, CompareBool :: Team(f0, f1, f2) =>
                    {
                        super :: CompareBool ::
                        Team(f0.lower(), f1.lower(), f2.lower())
                    }
                }
            }
        } impl Lower < super :: AggregateBool > for Spanned < AggregateBool >
        {
            fn lower(& self) -> super :: AggregateBool
            {
                match & self.node
                {
                    AggregateBool :: Compare(f0) =>
                    { super :: AggregateBool :: Compare(f0.lower()) },
                    AggregateBool :: CardSetEmpty(f0) =>
                    { super :: AggregateBool :: CardSetEmpty(f0.lower()) },
                    AggregateBool :: CardSetNotEmpty(f0) =>
                    { super :: AggregateBool :: CardSetNotEmpty(f0.lower()) },
                    AggregateBool :: OutOfPlayer(f0, f1) =>
                    {
                        super :: AggregateBool ::
                        OutOfPlayer(f0.lower(), f1.lower())
                    }
                }
            }
        } impl Lower < super :: BoolExpr > for Spanned < BoolExpr >
        {
            fn lower(& self) -> super :: BoolExpr
            {
                match & self.node
                {
                    BoolExpr :: Binary(f0, f1, f2) =>
                    {
                        super :: BoolExpr ::
                        Binary(f0.lower(), f1.lower(), f2.lower())
                    }, BoolExpr :: Unary(f0, f1) =>
                    { super :: BoolExpr :: Unary(f0.lower(), f1.lower()) },
                    BoolExpr :: Aggregate(f0) =>
                    { super :: BoolExpr :: Aggregate(f0.lower()) }
                }
            }
        } impl Lower < super :: AggregateTeam > for Spanned < AggregateTeam >
        {
            fn lower(& self) -> super :: AggregateTeam
            {
                match & self.node
                {
                    AggregateTeam :: TeamOf(f0) =>
                    { super :: AggregateTeam :: TeamOf(f0.lower()) }
                }
            }
        } impl Lower < super :: TeamExpr > for Spanned < TeamExpr >
        {
            fn lower(& self) -> super :: TeamExpr
            {
                match & self.node
                {
                    TeamExpr :: Literal(f0) =>
                    { super :: TeamExpr :: Literal(f0.lower()) }, TeamExpr ::
                    Aggregate(f0) =>
                    { super :: TeamExpr :: Aggregate(f0.lower()) }
                }
            }
        } impl Lower < super :: QueryCardPosition > for Spanned <
        QueryCardPosition >
        {
            fn lower(& self) -> super :: QueryCardPosition
            {
                match & self.node
                {
                    QueryCardPosition :: At(f0, f1) =>
                    {
                        super :: QueryCardPosition :: At(f0.lower(), f1.lower())
                    }, QueryCardPosition :: Top(f0) =>
                    { super :: QueryCardPosition :: Top(f0.lower()) },
                    QueryCardPosition :: Bottom(f0) =>
                    { super :: QueryCardPosition :: Bottom(f0.lower()) }
                }
            }
        } impl Lower < super :: AggregateCardPosition > for Spanned <
        AggregateCardPosition >
        {
            fn lower(& self) -> super :: AggregateCardPosition
            {
                match & self.node
                {
                    AggregateCardPosition :: ExtremaPointMap(f0, f1, f2) =>
                    {
                        super :: AggregateCardPosition ::
                        ExtremaPointMap(f0.lower(), f1.lower(), f2.lower())
                    }, AggregateCardPosition :: ExtremaPrecedence(f0, f1, f2) =>
                    {
                        super :: AggregateCardPosition ::
                        ExtremaPrecedence(f0.lower(), f1.lower(), f2.lower())
                    }
                }
            }
        } impl Lower < super :: CardPosition > for Spanned < CardPosition >
        {
            fn lower(& self) -> super :: CardPosition
            {
                match & self.node
                {
                    CardPosition :: Query(f0) =>
                    { super :: CardPosition :: Query(f0.lower()) }, CardPosition
                    :: Aggregate(f0) =>
                    { super :: CardPosition :: Aggregate(f0.lower()) }
                }
            }
        } impl Lower < super :: Status > for Spanned < Status >
        {
            fn lower(& self) -> super :: Status
            {
                match & self.node
                {
                    Status :: FaceUp => super :: Status :: FaceUp, Status ::
                    FaceDown => super :: Status :: FaceDown, Status :: Private
                    => super :: Status :: Private
                }
            }
        } impl Lower < super :: Collection > for Spanned < Collection >
        {
            fn lower(& self) -> super :: Collection
            {
                match & self.node
                {
                    Collection :: IntCollection(f0) =>
                    { super :: Collection :: IntCollection(f0.lower()) },
                    Collection :: StringCollection(f0) =>
                    { super :: Collection :: StringCollection(f0.lower()) },
                    Collection :: LocationCollection(f0) =>
                    { super :: Collection :: LocationCollection(f0.lower()) },
                    Collection :: PlayerCollection(f0) =>
                    { super :: Collection :: PlayerCollection(f0.lower()) },
                    Collection :: TeamCollection(f0) =>
                    { super :: Collection :: TeamCollection(f0.lower()) },
                    Collection :: CardSet(f0) =>
                    { super :: Collection :: CardSet(f0.lower()) }
                }
            }
        } impl Lower < super :: IntCollection > for Spanned < IntCollection >
        {
            fn lower(& self) -> super :: IntCollection
            { super :: IntCollection { ints : self.node.ints.lower() } }
        } impl Lower < super :: StringCollection > for Spanned <
        StringCollection >
        {
            fn lower(& self) -> super :: StringCollection
            {
                super :: StringCollection
                { strings : self.node.strings.lower() }
            }
        } impl Lower < super :: LocationCollection > for Spanned <
        LocationCollection >
        {
            fn lower(& self) -> super :: LocationCollection
            {
                super :: LocationCollection
                { locations : self.node.locations.lower() }
            }
        } impl Lower < super :: RuntimePlayerCollection > for Spanned <
        RuntimePlayerCollection >
        {
            fn lower(& self) -> super :: RuntimePlayerCollection
            {
                match & self.node
                {
                    RuntimePlayerCollection :: PlayersOut => super ::
                    RuntimePlayerCollection :: PlayersOut,
                    RuntimePlayerCollection :: PlayersIn => super ::
                    RuntimePlayerCollection :: PlayersIn,
                    RuntimePlayerCollection :: Others => super ::
                    RuntimePlayerCollection :: Others
                }
            }
        } impl Lower < super :: AggregatePlayerCollection > for Spanned <
        AggregatePlayerCollection >
        {
            fn lower(& self) -> super :: AggregatePlayerCollection
            {
                match & self.node
                {
                    AggregatePlayerCollection :: Quantifier(f0) =>
                    {
                        super :: AggregatePlayerCollection :: Quantifier(f0.lower())
                    }
                }
            }
        } impl Lower < super :: PlayerCollection > for Spanned <
        PlayerCollection >
        {
            fn lower(& self) -> super :: PlayerCollection
            {
                match & self.node
                {
                    PlayerCollection :: Literal(f0) =>
                    { super :: PlayerCollection :: Literal(f0.lower()) },
                    PlayerCollection :: Aggregate(f0) =>
                    { super :: PlayerCollection :: Aggregate(f0.lower()) },
                    PlayerCollection :: Runtime(f0) =>
                    { super :: PlayerCollection :: Runtime(f0.lower()) }
                }
            }
        } impl Lower < super :: RuntimeTeamCollection > for Spanned <
        RuntimeTeamCollection >
        {
            fn lower(& self) -> super :: RuntimeTeamCollection
            {
                match & self.node
                {
                    RuntimeTeamCollection :: OtherTeams => super ::
                    RuntimeTeamCollection :: OtherTeams
                }
            }
        } impl Lower < super :: TeamCollection > for Spanned < TeamCollection
        >
        {
            fn lower(& self) -> super :: TeamCollection
            {
                match & self.node
                {
                    TeamCollection :: Literal(f0) =>
                    { super :: TeamCollection :: Literal(f0.lower()) },
                    TeamCollection :: Runtime(f0) =>
                    { super :: TeamCollection :: Runtime(f0.lower()) }
                }
            }
        } impl Lower < super :: CardSet > for Spanned < CardSet >
        {
            fn lower(& self) -> super :: CardSet
            {
                match & self.node
                {
                    CardSet :: Group(f0) =>
                    { super :: CardSet :: Group(f0.lower()) }, CardSet ::
                    GroupOwner(f0, f1) =>
                    { super :: CardSet :: GroupOwner(f0.lower(), f1.lower()) }
                }
            }
        } impl Lower < super :: Group > for Spanned < Group >
        {
            fn lower(& self) -> super :: Group
            {
                match & self.node
                {
                    Group :: Groupable(f0) =>
                    { super :: Group :: Groupable(f0.lower()) }, Group ::
                    Where(f0, f1) =>
                    { super :: Group :: Where(f0.lower(), f1.lower()) }, Group
                    :: NotCombo(f0, f1) =>
                    { super :: Group :: NotCombo(f0.lower(), f1.lower()) },
                    Group :: Combo(f0, f1) =>
                    { super :: Group :: Combo(f0.lower(), f1.lower()) }, Group
                    :: CardPosition(f0) =>
                    { super :: Group :: CardPosition(f0.lower()) }
                }
            }
        } impl Lower < super :: AggregateFilter > for Spanned <
        AggregateFilter >
        {
            fn lower(& self) -> super :: AggregateFilter
            {
                match & self.node
                {
                    AggregateFilter :: Size(f0, f1) =>
                    {
                        super :: AggregateFilter :: Size(f0.lower(), f1.lower())
                    }, AggregateFilter :: Same(f0) =>
                    { super :: AggregateFilter :: Same(f0.lower()) },
                    AggregateFilter :: Distinct(f0) =>
                    { super :: AggregateFilter :: Distinct(f0.lower()) },
                    AggregateFilter :: Adjacent(f0, f1) =>
                    {
                        super :: AggregateFilter :: Adjacent(f0.lower(), f1.lower())
                    }, AggregateFilter :: Higher(f0, f1) =>
                    {
                        super :: AggregateFilter :: Higher(f0.lower(), f1.lower())
                    }, AggregateFilter :: Lower(f0, f1) =>
                    {
                        super :: AggregateFilter :: Lower(f0.lower(), f1.lower())
                    }, AggregateFilter :: KeyString(f0, f1, f2) =>
                    {
                        super :: AggregateFilter ::
                        KeyString(f0.lower(), f1.lower(), f2.lower())
                    }, AggregateFilter :: Combo(f0) =>
                    { super :: AggregateFilter :: Combo(f0.lower()) },
                    AggregateFilter :: NotCombo(f0) =>
                    { super :: AggregateFilter :: NotCombo(f0.lower()) }
                }
            }
        } impl Lower < super :: FilterOp > for Spanned < FilterOp >
        {
            fn lower(& self) -> super :: FilterOp
            {
                match & self.node
                {
                    FilterOp :: And => super :: FilterOp :: And, FilterOp :: Or
                    => super :: FilterOp :: Or
                }
            }
        } impl Lower < super :: FilterExpr > for Spanned < FilterExpr >
        {
            fn lower(& self) -> super :: FilterExpr
            {
                match & self.node
                {
                    FilterExpr :: Aggregate(f0) =>
                    { super :: FilterExpr :: Aggregate(f0.lower()) }, FilterExpr
                    :: Binary(f0, f1, f2) =>
                    {
                        super :: FilterExpr ::
                        Binary(f0.lower(), f1.lower(), f2.lower())
                    }
                }
            }
        } impl Lower < super :: Game > for Spanned < Game >
        {
            fn lower(& self) -> super :: Game
            { super :: Game { flows : self.node.flows.lower() } }
        } impl Lower < super :: FlowComponent > for Spanned < FlowComponent >
        {
            fn lower(& self) -> super :: FlowComponent
            {
                match & self.node
                {
                    FlowComponent :: Stage(f0) =>
                    { super :: FlowComponent :: Stage(f0.lower()) },
                    FlowComponent :: Rule(f0) =>
                    { super :: FlowComponent :: Rule(f0.lower()) },
                    FlowComponent :: IfRule(f0) =>
                    { super :: FlowComponent :: IfRule(f0.lower()) },
                    FlowComponent :: ChoiceRule(f0) =>
                    { super :: FlowComponent :: ChoiceRule(f0.lower()) },
                    FlowComponent :: OptionalRule(f0) =>
                    { super :: FlowComponent :: OptionalRule(f0.lower()) },
                    FlowComponent :: Conditional(f0) =>
                    { super :: FlowComponent :: Conditional(f0.lower()) }
                }
            }
        } impl Lower < super :: SetUpRule > for Spanned < SetUpRule >
        {
            fn lower(& self) -> super :: SetUpRule
            {
                match & self.node
                {
                    SetUpRule :: CreatePlayer(f0) =>
                    { super :: SetUpRule :: CreatePlayer(f0.lower()) },
                    SetUpRule :: CreateTeams(f0) =>
                    { super :: SetUpRule :: CreateTeams(f0.lower()) }, SetUpRule
                    :: CreateTurnorder(f0) =>
                    { super :: SetUpRule :: CreateTurnorder(f0.lower()) },
                    SetUpRule :: CreateTurnorderRandom(f0) =>
                    { super :: SetUpRule :: CreateTurnorderRandom(f0.lower()) },
                    SetUpRule :: CreateLocation(f0, f1) =>
                    {
                        super :: SetUpRule :: CreateLocation(f0.lower(), f1.lower())
                    }, SetUpRule :: CreateCardOnLocation(f0, f1) =>
                    {
                        super :: SetUpRule ::
                        CreateCardOnLocation(f0.lower(), f1.lower())
                    }, SetUpRule :: CreateTokenOnLocation(f0, f1, f2) =>
                    {
                        super :: SetUpRule ::
                        CreateTokenOnLocation(f0.lower(), f1.lower(), f2.lower())
                    }, SetUpRule :: CreateCombo(f0, f1) =>
                    {
                        super :: SetUpRule :: CreateCombo(f0.lower(), f1.lower())
                    }, SetUpRule :: CreateMemoryWithMemoryType(f0, f1, f2) =>
                    {
                        super :: SetUpRule ::
                        CreateMemoryWithMemoryType(f0.lower(), f1.lower(),
                        f2.lower())
                    }, SetUpRule :: CreateMemory(f0, f1) =>
                    {
                        super :: SetUpRule :: CreateMemory(f0.lower(), f1.lower())
                    }, SetUpRule :: CreatePrecedence(f0, f1) =>
                    {
                        super :: SetUpRule ::
                        CreatePrecedence(f0.lower(), f1.lower())
                    }, SetUpRule :: CreatePointMap(f0, f1) =>
                    {
                        super :: SetUpRule :: CreatePointMap(f0.lower(), f1.lower())
                    }
                }
            }
        } impl Lower < super :: ActionRule > for Spanned < ActionRule >
        {
            fn lower(& self) -> super :: ActionRule
            {
                match & self.node
                {
                    ActionRule :: FlipAction(f0, f1) =>
                    {
                        super :: ActionRule :: FlipAction(f0.lower(), f1.lower())
                    }, ActionRule :: ShuffleAction(f0) =>
                    { super :: ActionRule :: ShuffleAction(f0.lower()) },
                    ActionRule :: PlayerOutOfStageAction(f0) =>
                    {
                        super :: ActionRule :: PlayerOutOfStageAction(f0.lower())
                    }, ActionRule :: PlayerOutOfGameSuccAction(f0) =>
                    {
                        super :: ActionRule :: PlayerOutOfGameSuccAction(f0.lower())
                    }, ActionRule :: PlayerOutOfGameFailAction(f0) =>
                    {
                        super :: ActionRule :: PlayerOutOfGameFailAction(f0.lower())
                    }, ActionRule :: SetMemory(f0, f1) =>
                    {
                        super :: ActionRule :: SetMemory(f0.lower(), f1.lower())
                    }, ActionRule :: ResetMemory(f0) =>
                    { super :: ActionRule :: ResetMemory(f0.lower()) },
                    ActionRule :: CycleAction(f0) =>
                    { super :: ActionRule :: CycleAction(f0.lower()) },
                    ActionRule :: BidAction(f0) =>
                    { super :: ActionRule :: BidAction(f0.lower()) }, ActionRule
                    :: BidMemoryAction(f0, f1) =>
                    {
                        super :: ActionRule ::
                        BidMemoryAction(f0.lower(), f1.lower())
                    }, ActionRule :: EndAction(f0) =>
                    { super :: ActionRule :: EndAction(f0.lower()) }, ActionRule
                    :: DemandAction(f0) =>
                    { super :: ActionRule :: DemandAction(f0.lower()) },
                    ActionRule :: DemandMemoryAction(f0, f1) =>
                    {
                        super :: ActionRule ::
                        DemandMemoryAction(f0.lower(), f1.lower())
                    }, ActionRule :: Move(f0) =>
                    { super :: ActionRule :: Move(f0.lower()) }
                }
            }
        } impl Lower < super :: ScoringRule > for Spanned < ScoringRule >
        {
            fn lower(& self) -> super :: ScoringRule
            {
                match & self.node
                {
                    ScoringRule :: ScoreRule(f0) =>
                    { super :: ScoringRule :: ScoreRule(f0.lower()) },
                    ScoringRule :: WinnerRule(f0) =>
                    { super :: ScoringRule :: WinnerRule(f0.lower()) }
                }
            }
        } impl Lower < super :: GameRule > for Spanned < GameRule >
        {
            fn lower(& self) -> super :: GameRule
            {
                match & self.node
                {
                    GameRule :: SetUp(f0) =>
                    { super :: GameRule :: SetUp(f0.lower()) }, GameRule ::
                    Action(f0) => { super :: GameRule :: Action(f0.lower()) },
                    GameRule :: Scoring(f0) =>
                    { super :: GameRule :: Scoring(f0.lower()) }
                }
            }
        } impl Lower < super :: SeqStage > for Spanned < SeqStage >
        {
            fn lower(& self) -> super :: SeqStage
            {
                super :: SeqStage
                {
                    stage : self.node.stage.lower(), player :
                    self.node.player.lower(), end_condition :
                    self.node.end_condition.lower(), flows :
                    self.node.flows.lower()
                }
            }
        } impl Lower < super :: Case > for Spanned < Case >
        {
            fn lower(& self) -> super :: Case
            {
                match & self.node
                {
                    Case :: Else(f0) => { super :: Case :: Else(f0.lower()) },
                    Case :: NoBool(f0) =>
                    { super :: Case :: NoBool(f0.lower()) }, Case ::
                    Bool(f0, f1) =>
                    { super :: Case :: Bool(f0.lower(), f1.lower()) }
                }
            }
        } impl Lower < super :: Conditional > for Spanned < Conditional >
        {
            fn lower(& self) -> super :: Conditional
            { super :: Conditional { cases : self.node.cases.lower() } }
        } impl Lower < super :: IfRule > for Spanned < IfRule >
        {
            fn lower(& self) -> super :: IfRule
            {
                super :: IfRule
                {
                    condition : self.node.condition.lower(), flows :
                    self.node.flows.lower()
                }
            }
        } impl Lower < super :: OptionalRule > for Spanned < OptionalRule >
        {
            fn lower(& self) -> super :: OptionalRule
            { super :: OptionalRule { flows : self.node.flows.lower() } }
        } impl Lower < super :: ChoiceRule > for Spanned < ChoiceRule >
        {
            fn lower(& self) -> super :: ChoiceRule
            { super :: ChoiceRule { options : self.node.options.lower() } }
        } impl Lower < super :: MoveType > for Spanned < MoveType >
        {
            fn lower(& self) -> super :: MoveType
            {
                match & self.node
                {
                    MoveType :: Deal(f0) =>
                    { super :: MoveType :: Deal(f0.lower()) }, MoveType ::
                    Exchange(f0) =>
                    { super :: MoveType :: Exchange(f0.lower()) }, MoveType ::
                    Classic(f0) => { super :: MoveType :: Classic(f0.lower()) },
                    MoveType :: Place(f0) =>
                    { super :: MoveType :: Place(f0.lower()) }
                }
            }
        } impl Lower < super :: MoveCardSet > for Spanned < MoveCardSet >
        {
            fn lower(& self) -> super :: MoveCardSet
            {
                match & self.node
                {
                    MoveCardSet :: Move(f0, f1, f2) =>
                    {
                        super :: MoveCardSet ::
                        Move(f0.lower(), f1.lower(), f2.lower())
                    }, MoveCardSet :: MoveQuantity(f0, f1, f2, f3) =>
                    {
                        super :: MoveCardSet ::
                        MoveQuantity(f0.lower(), f1.lower(), f2.lower(), f3.lower())
                    }
                }
            }
        } impl Lower < super :: ClassicMove > for Spanned < ClassicMove >
        {
            fn lower(& self) -> super :: ClassicMove
            {
                match & self.node
                {
                    ClassicMove :: MoveCardSet(f0) =>
                    { super :: ClassicMove :: MoveCardSet(f0.lower()) }
                }
            }
        } impl Lower < super :: DealMove > for Spanned < DealMove >
        {
            fn lower(& self) -> super :: DealMove
            {
                match & self.node
                {
                    DealMove :: MoveCardSet(f0) =>
                    { super :: DealMove :: MoveCardSet(f0.lower()) }
                }
            }
        } impl Lower < super :: ExchangeMove > for Spanned < ExchangeMove >
        {
            fn lower(& self) -> super :: ExchangeMove
            {
                match & self.node
                {
                    ExchangeMove :: MoveCardSet(f0) =>
                    { super :: ExchangeMove :: MoveCardSet(f0.lower()) }
                }
            }
        } impl Lower < super :: TokenMove > for Spanned < TokenMove >
        {
            fn lower(& self) -> super :: TokenMove
            {
                match & self.node
                {
                    TokenMove :: Place(f0, f1, f2) =>
                    {
                        super :: TokenMove ::
                        Place(f0.lower(), f1.lower(), f2.lower())
                    }, TokenMove :: PlaceQuantity(f0, f1, f2, f3) =>
                    {
                        super :: TokenMove ::
                        PlaceQuantity(f0.lower(), f1.lower(), f2.lower(),
                        f3.lower())
                    }
                }
            }
        } impl Lower < super :: TokenLocExpr > for Spanned < TokenLocExpr >
        {
            fn lower(& self) -> super :: TokenLocExpr
            {
                match & self.node
                {
                    TokenLocExpr :: Groupable(f0) =>
                    { super :: TokenLocExpr :: Groupable(f0.lower()) },
                    TokenLocExpr :: GroupablePlayers(f0, f1) =>
                    {
                        super :: TokenLocExpr ::
                        GroupablePlayers(f0.lower(), f1.lower())
                    }
                }
            }
        } impl Lower < super :: ScoreRule > for Spanned < ScoreRule >
        {
            fn lower(& self) -> super :: ScoreRule
            {
                match & self.node
                {
                    ScoreRule :: Score(f0, f1) =>
                    { super :: ScoreRule :: Score(f0.lower(), f1.lower()) },
                    ScoreRule :: ScoreMemory(f0, f1, f2) =>
                    {
                        super :: ScoreRule ::
                        ScoreMemory(f0.lower(), f1.lower(), f2.lower())
                    }
                }
            }
        } impl Lower < super :: WinnerType > for Spanned < WinnerType >
        {
            fn lower(& self) -> super :: WinnerType
            {
                match & self.node
                {
                    WinnerType :: Score => super :: WinnerType :: Score,
                    WinnerType :: Memory(f0) =>
                    { super :: WinnerType :: Memory(f0.lower()) }, WinnerType ::
                    Position => super :: WinnerType :: Position
                }
            }
        } impl Lower < super :: WinnerRule > for Spanned < WinnerRule >
        {
            fn lower(& self) -> super :: WinnerRule
            {
                match & self.node
                {
                    WinnerRule :: Winner(f0) =>
                    { super :: WinnerRule :: Winner(f0.lower()) }, WinnerRule ::
                    WinnerWith(f0, f1) =>
                    {
                        super :: WinnerRule :: WinnerWith(f0.lower(), f1.lower())
                    }
                }
            }
        } impl Walker for BinCompare
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                { Self :: Eq => {} Self :: Neq => {} }
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: BinCompare(self)) }
        } impl Walker for LogicBinOp
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                { Self :: And => {} Self :: Or => {} }
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: LogicBinOp(self)) }
        } impl Walker for IntOp
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Plus => {} Self :: Minus => {} Self :: Mul => {}
                    Self :: Div => {} Self :: Mod => {}
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: IntOp(self)) }
        } impl Walker for IntCompare
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Eq => {} Self :: Neq => {} Self :: Gt => {} Self ::
                    Lt => {} Self :: Ge => {} Self :: Le => {}
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: IntCompare(self)) }
        } impl Walker for Extrema
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                { Self :: Min => {} Self :: Max => {} }
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: Extrema(self)) }
        } impl Walker for OutOf
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: CurrentStage => {} Self :: Stage(_f0) =>
                    { _f0.walk(visitor); } Self :: Game => {} Self :: Play => {}
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: OutOf(self)) }
        } impl Walker for Groupable
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Location(_f0) => { _f0.walk(visitor); } Self ::
                    LocationCollection(_f0) => { _f0.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: Groupable(self)) }
        } impl Walker for Owner
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Player(_f0) => { _f0.walk(visitor); } Self ::
                    PlayerCollection(_f0) => { _f0.walk(visitor); } Self ::
                    Team(_f0) => { _f0.walk(visitor); } Self ::
                    TeamCollection(_f0) => { _f0.walk(visitor); } Self :: Table
                    => {}
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: Owner(self)) }
        } impl Walker for Quantity
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Int(_f0) => { _f0.walk(visitor); } Self ::
                    Quantifier(_f0) => { _f0.walk(visitor); } Self ::
                    IntRange(_f0) => { _f0.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: Quantity(self)) }
        } impl Walker for IntRange
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); self.op_int.walk(visitor);
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: IntRange(self)) }
        } impl Walker for Quantifier
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                { Self :: All => {} Self :: Any => {} }
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: Quantifier(self)) }
        } impl Walker for EndCondition
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: UntilBool(_f0) => { _f0.walk(visitor); } Self ::
                    UntilBoolRep(_f0, _f1, _f2) =>
                    { _f0.walk(visitor); _f1.walk(visitor); _f2.walk(visitor); }
                    Self :: UntilRep(_f0) => { _f0.walk(visitor); } Self ::
                    UntilEnd => {}
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: EndCondition(self)) }
        } impl Walker for Repititions
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); self.times.walk(visitor);
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: Repititions(self)) }
        } impl Walker for MemoryType
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Int(_f0) => { _f0.walk(visitor); } Self ::
                    String(_f0) => { _f0.walk(visitor); } Self :: CardSet(_f0)
                    => { _f0.walk(visitor); } Self :: Collection(_f0) =>
                    { _f0.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: MemoryType(self)) }
        } impl Walker for Players
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Player(_f0) => { _f0.walk(visitor); } Self ::
                    PlayerCollection(_f0) => { _f0.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: Players(self)) }
        } impl Walker for EndType
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Turn => {} Self :: Stage => {} Self ::
                    GameWithWinner(_f0) => { _f0.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: EndType(self)) }
        } impl Walker for DemandType
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: CardPosition(_f0) => { _f0.walk(visitor); } Self ::
                    String(_f0) => { _f0.walk(visitor); } Self :: Int(_f0) =>
                    { _f0.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: DemandType(self)) }
        } impl Walker for Types
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); self.types.walk(visitor);
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: Types(self)) }
        } impl Walker for RuntimePlayer
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Current => {} Self :: Next => {} Self :: Previous =>
                    {} Self :: Competitor => {}
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: RuntimePlayer(self)) }
        } impl Walker for QueryPlayer
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                { Self :: Turnorder(_f0) => { _f0.walk(visitor); } }
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: QueryPlayer(self)) }
        } impl Walker for AggregatePlayer
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: OwnerOfCardPostion(_f0) => { _f0.walk(visitor); }
                    Self :: OwnerOfMemory(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: AggregatePlayer(self)) }
        } impl Walker for PlayerExpr
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Literal(_f0) => { _f0.walk(visitor); } Self ::
                    Runtime(_f0) => { _f0.walk(visitor); } Self ::
                    Aggregate(_f0) => { _f0.walk(visitor); } Self :: Query(_f0)
                    => { _f0.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: PlayerExpr(self)) }
        } impl Walker for QueryInt
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: IntCollectionAt(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: QueryInt(self)) }
        } impl Walker for AggregateInt
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: SizeOf(_f0) => { _f0.walk(visitor); } Self ::
                    SumOfIntCollection(_f0) => { _f0.walk(visitor); } Self ::
                    SumOfCardSet(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); } Self ::
                    ExtremaCardset(_f0, _f1, _f2) =>
                    { _f0.walk(visitor); _f1.walk(visitor); _f2.walk(visitor); }
                    Self :: ExtremaIntCollection(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: AggregateInt(self)) }
        } impl Walker for RuntimeInt
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: StageRoundCounter => {} Self :: PlayRoundCounter =>
                    {}
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: RuntimeInt(self)) }
        } impl Walker for IntExpr
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Literal(_f0) => { _f0.walk(visitor); } Self ::
                    Binary(_f0, _f1, _f2) =>
                    { _f0.walk(visitor); _f1.walk(visitor); _f2.walk(visitor); }
                    Self :: Query(_f0) => { _f0.walk(visitor); } Self ::
                    Aggregate(_f0) => { _f0.walk(visitor); } Self ::
                    Runtime(_f0) => { _f0.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: IntExpr(self)) }
        } impl Walker for QueryString
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: KeyOf(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); } Self ::
                    StringCollectionAt(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: QueryString(self)) }
        } impl Walker for StringExpr
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Literal(_f0) => { _f0.walk(visitor); } Self ::
                    Query(_f0) => { _f0.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: StringExpr(self)) }
        } impl Walker for CardSetCompare
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                { Self :: Eq => {} Self :: Neq => {} }
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: CardSetCompare(self)) }
        } impl Walker for StringCompare
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                { Self :: Eq => {} Self :: Neq => {} }
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: StringCompare(self)) }
        } impl Walker for PlayerCompare
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                { Self :: Eq => {} Self :: Neq => {} }
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: PlayerCompare(self)) }
        } impl Walker for TeamCompare
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                { Self :: Eq => {} Self :: Neq => {} }
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: TeamCompare(self)) }
        } impl Walker for BoolOp
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                { Self :: And => {} Self :: Or => {} }
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: BoolOp(self)) }
        } impl Walker for UnaryOp
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self { Self :: Not => {} }
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: UnaryOp(self)) }
        } impl Walker for CompareBool
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Int(_f0, _f1, _f2) =>
                    { _f0.walk(visitor); _f1.walk(visitor); _f2.walk(visitor); }
                    Self :: CardSet(_f0, _f1, _f2) =>
                    { _f0.walk(visitor); _f1.walk(visitor); _f2.walk(visitor); }
                    Self :: String(_f0, _f1, _f2) =>
                    { _f0.walk(visitor); _f1.walk(visitor); _f2.walk(visitor); }
                    Self :: Player(_f0, _f1, _f2) =>
                    { _f0.walk(visitor); _f1.walk(visitor); _f2.walk(visitor); }
                    Self :: Team(_f0, _f1, _f2) =>
                    { _f0.walk(visitor); _f1.walk(visitor); _f2.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: CompareBool(self)) }
        } impl Walker for AggregateBool
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Compare(_f0) => { _f0.walk(visitor); } Self ::
                    CardSetEmpty(_f0) => { _f0.walk(visitor); } Self ::
                    CardSetNotEmpty(_f0) => { _f0.walk(visitor); } Self ::
                    OutOfPlayer(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: AggregateBool(self)) }
        } impl Walker for BoolExpr
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Binary(_f0, _f1, _f2) =>
                    { _f0.walk(visitor); _f1.walk(visitor); _f2.walk(visitor); }
                    Self :: Unary(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); } Self ::
                    Aggregate(_f0) => { _f0.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: BoolExpr(self)) }
        } impl Walker for AggregateTeam
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                { Self :: TeamOf(_f0) => { _f0.walk(visitor); } }
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: AggregateTeam(self)) }
        } impl Walker for TeamExpr
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Literal(_f0) => { _f0.walk(visitor); } Self ::
                    Aggregate(_f0) => { _f0.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: TeamExpr(self)) }
        } impl Walker for QueryCardPosition
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: At(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); } Self :: Top(_f0)
                    => { _f0.walk(visitor); } Self :: Bottom(_f0) =>
                    { _f0.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: QueryCardPosition(self)) }
        } impl Walker for AggregateCardPosition
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: ExtremaPointMap(_f0, _f1, _f2) =>
                    { _f0.walk(visitor); _f1.walk(visitor); _f2.walk(visitor); }
                    Self :: ExtremaPrecedence(_f0, _f1, _f2) =>
                    { _f0.walk(visitor); _f1.walk(visitor); _f2.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: AggregateCardPosition(self)) }
        } impl Walker for CardPosition
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Query(_f0) => { _f0.walk(visitor); } Self ::
                    Aggregate(_f0) => { _f0.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: CardPosition(self)) }
        } impl Walker for Status
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: FaceUp => {} Self :: FaceDown => {} Self :: Private
                    => {}
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: Status(self)) }
        } impl Walker for Collection
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: IntCollection(_f0) => { _f0.walk(visitor); } Self ::
                    StringCollection(_f0) => { _f0.walk(visitor); } Self ::
                    LocationCollection(_f0) => { _f0.walk(visitor); } Self ::
                    PlayerCollection(_f0) => { _f0.walk(visitor); } Self ::
                    TeamCollection(_f0) => { _f0.walk(visitor); } Self ::
                    CardSet(_f0) => { _f0.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: Collection(self)) }
        } impl Walker for IntCollection
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); self.ints.walk(visitor);
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: IntCollection(self)) }
        } impl Walker for StringCollection
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); self.strings.walk(visitor);
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: StringCollection(self)) }
        } impl Walker for LocationCollection
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); self.locations.walk(visitor);
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: LocationCollection(self)) }
        } impl Walker for RuntimePlayerCollection
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: PlayersOut => {} Self :: PlayersIn => {} Self ::
                    Others => {}
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: RuntimePlayerCollection(self)) }
        } impl Walker for AggregatePlayerCollection
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                { Self :: Quantifier(_f0) => { _f0.walk(visitor); } }
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: AggregatePlayerCollection(self)) }
        } impl Walker for PlayerCollection
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Literal(_f0) => { _f0.walk(visitor); } Self ::
                    Aggregate(_f0) => { _f0.walk(visitor); } Self ::
                    Runtime(_f0) => { _f0.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: PlayerCollection(self)) }
        } impl Walker for RuntimeTeamCollection
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                { Self :: OtherTeams => {} } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: RuntimeTeamCollection(self)) }
        } impl Walker for TeamCollection
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Literal(_f0) => { _f0.walk(visitor); } Self ::
                    Runtime(_f0) => { _f0.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: TeamCollection(self)) }
        } impl Walker for CardSet
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Group(_f0) => { _f0.walk(visitor); } Self ::
                    GroupOwner(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: CardSet(self)) }
        } impl Walker for Group
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Groupable(_f0) => { _f0.walk(visitor); } Self ::
                    Where(_f0, _f1) => { _f0.walk(visitor); _f1.walk(visitor); }
                    Self :: NotCombo(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); } Self ::
                    Combo(_f0, _f1) => { _f0.walk(visitor); _f1.walk(visitor); }
                    Self :: CardPosition(_f0) => { _f0.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: Group(self)) }
        } impl Walker for AggregateFilter
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Size(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); } Self :: Same(_f0)
                    => { _f0.walk(visitor); } Self :: Distinct(_f0) =>
                    { _f0.walk(visitor); } Self :: Adjacent(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); } Self ::
                    Higher(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); } Self ::
                    Lower(_f0, _f1) => { _f0.walk(visitor); _f1.walk(visitor); }
                    Self :: KeyString(_f0, _f1, _f2) =>
                    { _f0.walk(visitor); _f1.walk(visitor); _f2.walk(visitor); }
                    Self :: Combo(_f0) => { _f0.walk(visitor); } Self ::
                    NotCombo(_f0) => { _f0.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: AggregateFilter(self)) }
        } impl Walker for FilterOp
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                { Self :: And => {} Self :: Or => {} }
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: FilterOp(self)) }
        } impl Walker for FilterExpr
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Aggregate(_f0) => { _f0.walk(visitor); } Self ::
                    Binary(_f0, _f1, _f2) =>
                    { _f0.walk(visitor); _f1.walk(visitor); _f2.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: FilterExpr(self)) }
        } impl Walker for Game
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); self.flows.walk(visitor);
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: Game(self)) }
        } impl Walker for FlowComponent
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Stage(_f0) => { _f0.walk(visitor); } Self ::
                    Rule(_f0) => { _f0.walk(visitor); } Self :: IfRule(_f0) =>
                    { _f0.walk(visitor); } Self :: ChoiceRule(_f0) =>
                    { _f0.walk(visitor); } Self :: OptionalRule(_f0) =>
                    { _f0.walk(visitor); } Self :: Conditional(_f0) =>
                    { _f0.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: FlowComponent(self)) }
        } impl Walker for SetUpRule
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: CreatePlayer(_f0) => { _f0.walk(visitor); } Self ::
                    CreateTeams(_f0) => { _f0.walk(visitor); } Self ::
                    CreateTurnorder(_f0) => { _f0.walk(visitor); } Self ::
                    CreateTurnorderRandom(_f0) => { _f0.walk(visitor); } Self ::
                    CreateLocation(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); } Self ::
                    CreateCardOnLocation(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); } Self ::
                    CreateTokenOnLocation(_f0, _f1, _f2) =>
                    { _f0.walk(visitor); _f1.walk(visitor); _f2.walk(visitor); }
                    Self :: CreateCombo(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); } Self ::
                    CreateMemoryWithMemoryType(_f0, _f1, _f2) =>
                    { _f0.walk(visitor); _f1.walk(visitor); _f2.walk(visitor); }
                    Self :: CreateMemory(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); } Self ::
                    CreatePrecedence(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); } Self ::
                    CreatePointMap(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: SetUpRule(self)) }
        } impl Walker for ActionRule
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: FlipAction(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); } Self ::
                    ShuffleAction(_f0) => { _f0.walk(visitor); } Self ::
                    PlayerOutOfStageAction(_f0) => { _f0.walk(visitor); } Self
                    :: PlayerOutOfGameSuccAction(_f0) => { _f0.walk(visitor); }
                    Self :: PlayerOutOfGameFailAction(_f0) =>
                    { _f0.walk(visitor); } Self :: SetMemory(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); } Self ::
                    ResetMemory(_f0) => { _f0.walk(visitor); } Self ::
                    CycleAction(_f0) => { _f0.walk(visitor); } Self ::
                    BidAction(_f0) => { _f0.walk(visitor); } Self ::
                    BidMemoryAction(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); } Self ::
                    EndAction(_f0) => { _f0.walk(visitor); } Self ::
                    DemandAction(_f0) => { _f0.walk(visitor); } Self ::
                    DemandMemoryAction(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); } Self :: Move(_f0)
                    => { _f0.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: ActionRule(self)) }
        } impl Walker for ScoringRule
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: ScoreRule(_f0) => { _f0.walk(visitor); } Self ::
                    WinnerRule(_f0) => { _f0.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: ScoringRule(self)) }
        } impl Walker for GameRule
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: SetUp(_f0) => { _f0.walk(visitor); } Self ::
                    Action(_f0) => { _f0.walk(visitor); } Self :: Scoring(_f0)
                    => { _f0.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: GameRule(self)) }
        } impl Walker for SeqStage
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); self.stage.walk(visitor);
                self.player.walk(visitor); self.end_condition.walk(visitor);
                self.flows.walk(visitor); visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: SeqStage(self)) }
        } impl Walker for Case
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Else(_f0) => { _f0.walk(visitor); } Self ::
                    NoBool(_f0) => { _f0.walk(visitor); } Self :: Bool(_f0, _f1)
                    => { _f0.walk(visitor); _f1.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: Case(self)) }
        } impl Walker for Conditional
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); self.cases.walk(visitor);
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: Conditional(self)) }
        } impl Walker for IfRule
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); self.condition.walk(visitor);
                self.flows.walk(visitor); visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: IfRule(self)) }
        } impl Walker for OptionalRule
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); self.flows.walk(visitor);
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: OptionalRule(self)) }
        } impl Walker for ChoiceRule
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); self.options.walk(visitor);
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: ChoiceRule(self)) }
        } impl Walker for MoveType
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Deal(_f0) => { _f0.walk(visitor); } Self ::
                    Exchange(_f0) => { _f0.walk(visitor); } Self :: Classic(_f0)
                    => { _f0.walk(visitor); } Self :: Place(_f0) =>
                    { _f0.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: MoveType(self)) }
        } impl Walker for MoveCardSet
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Move(_f0, _f1, _f2) =>
                    { _f0.walk(visitor); _f1.walk(visitor); _f2.walk(visitor); }
                    Self :: MoveQuantity(_f0, _f1, _f2, _f3) =>
                    {
                        _f0.walk(visitor); _f1.walk(visitor); _f2.walk(visitor);
                        _f3.walk(visitor);
                    }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: MoveCardSet(self)) }
        } impl Walker for ClassicMove
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                { Self :: MoveCardSet(_f0) => { _f0.walk(visitor); } }
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: ClassicMove(self)) }
        } impl Walker for DealMove
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                { Self :: MoveCardSet(_f0) => { _f0.walk(visitor); } }
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: DealMove(self)) }
        } impl Walker for ExchangeMove
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                { Self :: MoveCardSet(_f0) => { _f0.walk(visitor); } }
                visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: ExchangeMove(self)) }
        } impl Walker for TokenMove
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Place(_f0, _f1, _f2) =>
                    { _f0.walk(visitor); _f1.walk(visitor); _f2.walk(visitor); }
                    Self :: PlaceQuantity(_f0, _f1, _f2, _f3) =>
                    {
                        _f0.walk(visitor); _f1.walk(visitor); _f2.walk(visitor);
                        _f3.walk(visitor);
                    }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: TokenMove(self)) }
        } impl Walker for TokenLocExpr
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Groupable(_f0) => { _f0.walk(visitor); } Self ::
                    GroupablePlayers(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: TokenLocExpr(self)) }
        } impl Walker for ScoreRule
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Score(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); } Self ::
                    ScoreMemory(_f0, _f1, _f2) =>
                    { _f0.walk(visitor); _f1.walk(visitor); _f2.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: ScoreRule(self)) }
        } impl Walker for WinnerType
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Score => {} Self :: Memory(_f0) =>
                    { _f0.walk(visitor); } Self :: Position => {}
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: WinnerType(self)) }
        } impl Walker for WinnerRule
        {
            fn walk < V : AstPass > (& self, visitor : & mut V)
            {
                visitor.enter_node(self); match self
                {
                    Self :: Winner(_f0) => { _f0.walk(visitor); } Self ::
                    WinnerWith(_f0, _f1) =>
                    { _f0.walk(visitor); _f1.walk(visitor); }
                } visitor.exit_node(self);
            } fn kind(& self) -> Option < NodeKind >
            { Some(NodeKind :: WinnerRule(self)) }
        } pub enum NodeKind < 'a >
        {
            BinCompare(& 'a BinCompare), LogicBinOp(& 'a LogicBinOp),
            IntOp(& 'a IntOp), IntCompare(& 'a IntCompare),
            Extrema(& 'a Extrema), OutOf(& 'a OutOf),
            Groupable(& 'a Groupable), Owner(& 'a Owner),
            Quantity(& 'a Quantity), IntRange(& 'a IntRange),
            Quantifier(& 'a Quantifier), EndCondition(& 'a EndCondition),
            Repititions(& 'a Repititions), MemoryType(& 'a MemoryType),
            Players(& 'a Players), EndType(& 'a EndType),
            DemandType(& 'a DemandType), Types(& 'a Types),
            RuntimePlayer(& 'a RuntimePlayer), QueryPlayer(& 'a QueryPlayer),
            AggregatePlayer(& 'a AggregatePlayer),
            PlayerExpr(& 'a PlayerExpr), QueryInt(& 'a QueryInt),
            AggregateInt(& 'a AggregateInt), RuntimeInt(& 'a RuntimeInt),
            IntExpr(& 'a IntExpr), QueryString(& 'a QueryString),
            StringExpr(& 'a StringExpr), CardSetCompare(& 'a CardSetCompare),
            StringCompare(& 'a StringCompare),
            PlayerCompare(& 'a PlayerCompare), TeamCompare(& 'a TeamCompare),
            BoolOp(& 'a BoolOp), UnaryOp(& 'a UnaryOp),
            CompareBool(& 'a CompareBool), AggregateBool(& 'a AggregateBool),
            BoolExpr(& 'a BoolExpr), AggregateTeam(& 'a AggregateTeam),
            TeamExpr(& 'a TeamExpr),
            QueryCardPosition(& 'a QueryCardPosition),
            AggregateCardPosition(& 'a AggregateCardPosition),
            CardPosition(& 'a CardPosition), Status(& 'a Status),
            Collection(& 'a Collection), IntCollection(& 'a IntCollection),
            StringCollection(& 'a StringCollection),
            LocationCollection(& 'a LocationCollection),
            RuntimePlayerCollection(& 'a RuntimePlayerCollection),
            AggregatePlayerCollection(& 'a AggregatePlayerCollection),
            PlayerCollection(& 'a PlayerCollection),
            RuntimeTeamCollection(& 'a RuntimeTeamCollection),
            TeamCollection(& 'a TeamCollection), CardSet(& 'a CardSet),
            Group(& 'a Group), AggregateFilter(& 'a AggregateFilter),
            FilterOp(& 'a FilterOp), FilterExpr(& 'a FilterExpr),
            Game(& 'a Game), FlowComponent(& 'a FlowComponent),
            SetUpRule(& 'a SetUpRule), ActionRule(& 'a ActionRule),
            ScoringRule(& 'a ScoringRule), GameRule(& 'a GameRule),
            SeqStage(& 'a SeqStage), Case(& 'a Case),
            Conditional(& 'a Conditional), IfRule(& 'a IfRule),
            OptionalRule(& 'a OptionalRule), ChoiceRule(& 'a ChoiceRule),
            MoveType(& 'a MoveType), MoveCardSet(& 'a MoveCardSet),
            ClassicMove(& 'a ClassicMove), DealMove(& 'a DealMove),
            ExchangeMove(& 'a ExchangeMove), TokenMove(& 'a TokenMove),
            TokenLocExpr(& 'a TokenLocExpr), ScoreRule(& 'a ScoreRule),
            WinnerType(& 'a WinnerType), WinnerRule(& 'a WinnerRule)
        }
    }
}
error[E0432]: unresolved import `crate::ast::ast::spanned_ast`
 --> front_end/src/parser.rs:4:22
  |
4 | use crate::ast::ast::spanned_ast::*;
  |                      ^^^^^^^^^^^ could not find `spanned_ast` in `ast`

error[E0432]: unresolved import `crate::ast::ast::spanned_ast`
 --> front_end/src/ir.rs:5:22
  |
5 | use crate::ast::ast::spanned_ast::*;
  |                      ^^^^^^^^^^^ could not find `spanned_ast` in `ast`

error[E0432]: unresolved import `crate::ast::ast::SID`
 --> front_end/src/symbols.rs:3:5
  |
3 | use crate::ast::ast::SID;
  |     ^^^^^^^^^^^^^^^^^^^^ no `SID` in `ast::ast`
  |
help: consider importing this type alias instead
  |
3 - use crate::ast::ast::SID;
3 + use crate::spans::SID;
  |

error[E0432]: unresolved import `crate::ast::ast::NodeKind`
 --> front_end/src/symbols.rs:7:5
  |
7 | use crate::ast::ast::NodeKind as NodeKind;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `NodeKind` in `ast::ast`
  |
help: consider importing this enum instead
  |
7 - use crate::ast::ast::NodeKind as NodeKind;
7 + use crate::symbols::ast_spanned::NodeKind;
  |

error[E0432]: unresolved import `crate::ast::ast::NodeKind`
 --> front_end/src/semantic.rs:3:24
  |
3 | use crate::{ast::ast::{NodeKind, *}, spans::OwnedSpan, symbols::Var, walker::AstPass};
  |                        ^^^^^^^^ no `NodeKind` in `ast::ast`
  |
  = help: consider importing this enum instead:
          crate::semantic::ast_spanned::NodeKind

error[E0432]: unresolved import `crate::ast::ast::spanned_ast`
 --> front_end/src/walker.rs:3:22
  |
3 | use crate::ast::ast::spanned_ast::NodeKind as NodeKind;
  |                      ^^^^^^^^^^^ could not find `spanned_ast` in `ast`

error[E0432]: unresolved import `crate::ast::ast::SGame`
 --> front_end/src/validation.rs:8:13
  |
8 | use crate::{ast::ast::SGame, parser::{CGDSLParser, Rule}, symbols::{SymbolError, SymbolVisitor}, walker::Walker};
  |             ^^^^^^^^^^-----
  |             |         |
  |             |         help: a similar name exists in the module: `Game`
  |             no `SGame` in `ast::ast`
  |
  = help: consider importing this type alias instead:
          crate::ast::ast::ast_spanned::SGame

error[E0599]: the method `lower` exists for struct `spans::Spanned<Vec<(ast_spanned::IntCompare, ast_spanned::IntExpr)>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 | #[spanned_ast]
    | ^^^^^^^^^^^^^^ method cannot be called due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 | pub struct Spanned<T> {
    | --------------------- method `lower` not found for this struct because it doesn't satisfy `_: Lower<_>`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:434:1
    |
434 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `_: Lower<_>`
    |
note: trait bound `Vec<(ast_spanned::IntCompare, ast_spanned::IntExpr)>: lower::Lower<_>` was not satisfied
   --> front_end/src/lower.rs:10:8
    |
  8 | impl<T, U> Lower<U> for Spanned<T>
    |            --------     ----------
  9 | where
 10 |     T: Lower<U>,
    |        ^^^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `lower`, perhaps you need to implement one of them:
            candidate #1: `lower::Lower`
            candidate #2: `regex_syntax::hir::interval::Interval`
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `lower` exists for struct `spans::Spanned<Vec<(std::string::String, Vec<std::string::String>)>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 | #[spanned_ast]
    | ^^^^^^^^^^^^^^ method cannot be called due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 | pub struct Spanned<T> {
    | --------------------- method `lower` not found for this struct because it doesn't satisfy `_: Lower<_>`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:434:1
    |
434 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `_: Lower<_>`
    |
note: trait bound `Vec<(std::string::String, Vec<std::string::String>)>: lower::Lower<_>` was not satisfied
   --> front_end/src/lower.rs:10:8
    |
  8 | impl<T, U> Lower<U> for Spanned<T>
    |            --------     ----------
  9 | where
 10 |     T: Lower<U>,
    |        ^^^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `lower`, perhaps you need to implement one of them:
            candidate #1: `lower::Lower`
            candidate #2: `regex_syntax::hir::interval::Interval`
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `lower` exists for reference `&spans::Spanned<Box<ast_spanned::CardPosition>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 |   #[spanned_ast]
    |   ^^^^^^^^^^^^^^ method cannot be called on `&spans::Spanned<Box<ast_spanned::CardPosition>>` due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 |   pub struct Spanned<T> {
    |   --------------------- doesn't satisfy `_: Lower<_>`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:231:1
    |
231 | / pub struct Box<
232 | |     T: ?Sized,
233 | |     #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global,
234 | | >(Unique<T>, A);
    | |_- doesn't satisfy `Box<ast_spanned::CardPosition>: lower::Lower<_>`
    |
note: trait bound `Box<ast_spanned::CardPosition>: lower::Lower<_>` was not satisfied
   --> front_end/src/lower.rs:10:8
    |
  8 | impl<T, U> Lower<U> for Spanned<T>
    |            --------     ----------
  9 | where
 10 |     T: Lower<U>,
    |        ^^^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `lower`, perhaps you need to implement one of them:
            candidate #1: `lower::Lower`
            candidate #2: `regex_syntax::hir::interval::Interval`
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `lower` exists for reference `&spans::Spanned<Box<ast_spanned::IntCollection>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 |   #[spanned_ast]
    |   ^^^^^^^^^^^^^^ method cannot be called on `&spans::Spanned<Box<ast_spanned::IntCollection>>` due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 |   pub struct Spanned<T> {
    |   --------------------- doesn't satisfy `_: Lower<_>`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:231:1
    |
231 | / pub struct Box<
232 | |     T: ?Sized,
233 | |     #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global,
234 | | >(Unique<T>, A);
    | |_- doesn't satisfy `Box<ast_spanned::IntCollection>: lower::Lower<_>`
    |
note: trait bound `Box<ast_spanned::IntCollection>: lower::Lower<_>` was not satisfied
   --> front_end/src/lower.rs:10:8
    |
  8 | impl<T, U> Lower<U> for Spanned<T>
    |            --------     ----------
  9 | where
 10 |     T: Lower<U>,
    |        ^^^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `lower`, perhaps you need to implement one of them:
            candidate #1: `lower::Lower`
            candidate #2: `regex_syntax::hir::interval::Interval`
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `lower` exists for reference `&spans::Spanned<Box<ast_spanned::IntExpr>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 |   #[spanned_ast]
    |   ^^^^^^^^^^^^^^ method cannot be called on `&spans::Spanned<Box<ast_spanned::IntExpr>>` due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 |   pub struct Spanned<T> {
    |   --------------------- doesn't satisfy `_: Lower<_>`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:231:1
    |
231 | / pub struct Box<
232 | |     T: ?Sized,
233 | |     #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global,
234 | | >(Unique<T>, A);
    | |_- doesn't satisfy `Box<ast_spanned::IntExpr>: lower::Lower<_>`
    |
note: trait bound `Box<ast_spanned::IntExpr>: lower::Lower<_>` was not satisfied
   --> front_end/src/lower.rs:10:8
    |
  8 | impl<T, U> Lower<U> for Spanned<T>
    |            --------     ----------
  9 | where
 10 |     T: Lower<U>,
    |        ^^^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `lower`, perhaps you need to implement one of them:
            candidate #1: `lower::Lower`
            candidate #2: `regex_syntax::hir::interval::Interval`
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `lower` exists for reference `&spans::Spanned<Box<ast_spanned::CardSet>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 |   #[spanned_ast]
    |   ^^^^^^^^^^^^^^ method cannot be called on `&spans::Spanned<Box<ast_spanned::CardSet>>` due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 |   pub struct Spanned<T> {
    |   --------------------- doesn't satisfy `_: Lower<_>`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:231:1
    |
231 | / pub struct Box<
232 | |     T: ?Sized,
233 | |     #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global,
234 | | >(Unique<T>, A);
    | |_- doesn't satisfy `Box<ast_spanned::CardSet>: lower::Lower<_>`
    |
note: trait bound `Box<ast_spanned::CardSet>: lower::Lower<_>` was not satisfied
   --> front_end/src/lower.rs:10:8
    |
  8 | impl<T, U> Lower<U> for Spanned<T>
    |            --------     ----------
  9 | where
 10 |     T: Lower<U>,
    |        ^^^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `lower`, perhaps you need to implement one of them:
            candidate #1: `lower::Lower`
            candidate #2: `regex_syntax::hir::interval::Interval`
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `lower` exists for reference `&spans::Spanned<Box<ast_spanned::BoolExpr>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 |   #[spanned_ast]
    |   ^^^^^^^^^^^^^^ method cannot be called on `&spans::Spanned<Box<ast_spanned::BoolExpr>>` due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 |   pub struct Spanned<T> {
    |   --------------------- doesn't satisfy `_: Lower<_>`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:231:1
    |
231 | / pub struct Box<
232 | |     T: ?Sized,
233 | |     #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global,
234 | | >(Unique<T>, A);
    | |_- doesn't satisfy `Box<ast_spanned::BoolExpr>: lower::Lower<_>`
    |
note: trait bound `Box<ast_spanned::BoolExpr>: lower::Lower<_>` was not satisfied
   --> front_end/src/lower.rs:10:8
    |
  8 | impl<T, U> Lower<U> for Spanned<T>
    |            --------     ----------
  9 | where
 10 |     T: Lower<U>,
    |        ^^^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `lower`, perhaps you need to implement one of them:
            candidate #1: `lower::Lower`
            candidate #2: `regex_syntax::hir::interval::Interval`
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `lower` exists for struct `spans::Spanned<Vec<ast_spanned::IntExpr>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 | #[spanned_ast]
    | ^^^^^^^^^^^^^^ method cannot be called on `spans::Spanned<Vec<ast_spanned::IntExpr>>` due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 | pub struct Spanned<T> {
    | --------------------- method `lower` not found for this struct because it doesn't satisfy `_: Lower<_>`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:434:1
    |
434 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<ast_spanned::IntExpr>: lower::Lower<_>`
    |
note: trait bound `Vec<ast_spanned::IntExpr>: lower::Lower<_>` was not satisfied
   --> front_end/src/lower.rs:10:8
    |
  8 | impl<T, U> Lower<U> for Spanned<T>
    |            --------     ----------
  9 | where
 10 |     T: Lower<U>,
    |        ^^^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `lower`, perhaps you need to implement one of them:
            candidate #1: `lower::Lower`
            candidate #2: `regex_syntax::hir::interval::Interval`
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `lower` exists for struct `spans::Spanned<Vec<ast_spanned::StringExpr>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 | #[spanned_ast]
    | ^^^^^^^^^^^^^^ method cannot be called on `spans::Spanned<Vec<ast_spanned::StringExpr>>` due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 | pub struct Spanned<T> {
    | --------------------- method `lower` not found for this struct because it doesn't satisfy `_: Lower<_>`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:434:1
    |
434 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<ast_spanned::StringExpr>: lower::Lower<_>`
    |
note: trait bound `Vec<ast_spanned::StringExpr>: lower::Lower<_>` was not satisfied
   --> front_end/src/lower.rs:10:8
    |
  8 | impl<T, U> Lower<U> for Spanned<T>
    |            --------     ----------
  9 | where
 10 |     T: Lower<U>,
    |        ^^^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `lower`, perhaps you need to implement one of them:
            candidate #1: `lower::Lower`
            candidate #2: `regex_syntax::hir::interval::Interval`
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `lower` exists for struct `spans::Spanned<Vec<std::string::String>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 | #[spanned_ast]
    | ^^^^^^^^^^^^^^ method cannot be called on `spans::Spanned<Vec<std::string::String>>` due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 | pub struct Spanned<T> {
    | --------------------- method `lower` not found for this struct because it doesn't satisfy `_: Lower<_>`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:434:1
    |
434 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<std::string::String>: lower::Lower<_>`
    |
note: trait bound `Vec<std::string::String>: lower::Lower<_>` was not satisfied
   --> front_end/src/lower.rs:10:8
    |
  8 | impl<T, U> Lower<U> for Spanned<T>
    |            --------     ----------
  9 | where
 10 |     T: Lower<U>,
    |        ^^^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `lower`, perhaps you need to implement one of them:
            candidate #1: `lower::Lower`
            candidate #2: `regex_syntax::hir::interval::Interval`
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `lower` exists for reference `&spans::Spanned<Vec<ast_spanned::PlayerExpr>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 | #[spanned_ast]
    | ^^^^^^^^^^^^^^ method cannot be called on `&spans::Spanned<Vec<ast_spanned::PlayerExpr>>` due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 | pub struct Spanned<T> {
    | --------------------- doesn't satisfy `_: Lower<_>`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:434:1
    |
434 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<ast_spanned::PlayerExpr>: lower::Lower<_>`
    |
note: trait bound `Vec<ast_spanned::PlayerExpr>: lower::Lower<_>` was not satisfied
   --> front_end/src/lower.rs:10:8
    |
  8 | impl<T, U> Lower<U> for Spanned<T>
    |            --------     ----------
  9 | where
 10 |     T: Lower<U>,
    |        ^^^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `lower`, perhaps you need to implement one of them:
            candidate #1: `lower::Lower`
            candidate #2: `regex_syntax::hir::interval::Interval`
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `lower` exists for reference `&spans::Spanned<Vec<ast_spanned::TeamExpr>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 | #[spanned_ast]
    | ^^^^^^^^^^^^^^ method cannot be called on `&spans::Spanned<Vec<ast_spanned::TeamExpr>>` due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 | pub struct Spanned<T> {
    | --------------------- doesn't satisfy `_: Lower<_>`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:434:1
    |
434 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<ast_spanned::TeamExpr>: lower::Lower<_>`
    |
note: trait bound `Vec<ast_spanned::TeamExpr>: lower::Lower<_>` was not satisfied
   --> front_end/src/lower.rs:10:8
    |
  8 | impl<T, U> Lower<U> for Spanned<T>
    |            --------     ----------
  9 | where
 10 |     T: Lower<U>,
    |        ^^^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `lower`, perhaps you need to implement one of them:
            candidate #1: `lower::Lower`
            candidate #2: `regex_syntax::hir::interval::Interval`
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `lower` exists for reference `&spans::Spanned<Box<ast_spanned::StringExpr>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 |   #[spanned_ast]
    |   ^^^^^^^^^^^^^^ method cannot be called on `&spans::Spanned<Box<ast_spanned::StringExpr>>` due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 |   pub struct Spanned<T> {
    |   --------------------- doesn't satisfy `_: Lower<_>`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:231:1
    |
231 | / pub struct Box<
232 | |     T: ?Sized,
233 | |     #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global,
234 | | >(Unique<T>, A);
    | |_- doesn't satisfy `Box<ast_spanned::StringExpr>: lower::Lower<_>`
    |
note: trait bound `Box<ast_spanned::StringExpr>: lower::Lower<_>` was not satisfied
   --> front_end/src/lower.rs:10:8
    |
  8 | impl<T, U> Lower<U> for Spanned<T>
    |            --------     ----------
  9 | where
 10 |     T: Lower<U>,
    |        ^^^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `lower`, perhaps you need to implement one of them:
            candidate #1: `lower::Lower`
            candidate #2: `regex_syntax::hir::interval::Interval`
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `lower` exists for reference `&spans::Spanned<Box<ast_spanned::FilterExpr>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 |   #[spanned_ast]
    |   ^^^^^^^^^^^^^^ method cannot be called on `&spans::Spanned<Box<ast_spanned::FilterExpr>>` due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 |   pub struct Spanned<T> {
    |   --------------------- doesn't satisfy `_: Lower<_>`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:231:1
    |
231 | / pub struct Box<
232 | |     T: ?Sized,
233 | |     #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global,
234 | | >(Unique<T>, A);
    | |_- doesn't satisfy `Box<ast_spanned::FilterExpr>: lower::Lower<_>`
    |
note: trait bound `Box<ast_spanned::FilterExpr>: lower::Lower<_>` was not satisfied
   --> front_end/src/lower.rs:10:8
    |
  8 | impl<T, U> Lower<U> for Spanned<T>
    |            --------     ----------
  9 | where
 10 |     T: Lower<U>,
    |        ^^^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `lower`, perhaps you need to implement one of them:
            candidate #1: `lower::Lower`
            candidate #2: `regex_syntax::hir::interval::Interval`
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `lower` exists for struct `spans::Spanned<Vec<ast_spanned::FlowComponent>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 | #[spanned_ast]
    | ^^^^^^^^^^^^^^ method cannot be called on `spans::Spanned<Vec<ast_spanned::FlowComponent>>` due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 | pub struct Spanned<T> {
    | --------------------- method `lower` not found for this struct because it doesn't satisfy `_: Lower<_>`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:434:1
    |
434 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<ast_spanned::FlowComponent>: lower::Lower<_>`
    |
note: trait bound `Vec<ast_spanned::FlowComponent>: lower::Lower<_>` was not satisfied
   --> front_end/src/lower.rs:10:8
    |
  8 | impl<T, U> Lower<U> for Spanned<T>
    |            --------     ----------
  9 | where
 10 |     T: Lower<U>,
    |        ^^^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `lower`, perhaps you need to implement one of them:
            candidate #1: `lower::Lower`
            candidate #2: `regex_syntax::hir::interval::Interval`
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `lower` exists for reference `&spans::Spanned<Vec<std::string::String>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 | #[spanned_ast]
    | ^^^^^^^^^^^^^^ method cannot be called on `&spans::Spanned<Vec<std::string::String>>` due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 | pub struct Spanned<T> {
    | --------------------- doesn't satisfy `_: Lower<_>`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:434:1
    |
434 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<std::string::String>: lower::Lower<_>`
    |
note: trait bound `Vec<std::string::String>: lower::Lower<_>` was not satisfied
   --> front_end/src/lower.rs:10:8
    |
  8 | impl<T, U> Lower<U> for Spanned<T>
    |            --------     ----------
  9 | where
 10 |     T: Lower<U>,
    |        ^^^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `lower`, perhaps you need to implement one of them:
            candidate #1: `lower::Lower`
            candidate #2: `regex_syntax::hir::interval::Interval`
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `lower` exists for reference `&spans::Spanned<Vec<(std::string::String, ast_spanned::PlayerCollection)>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 | #[spanned_ast]
    | ^^^^^^^^^^^^^^ method cannot be called due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 | pub struct Spanned<T> {
    | --------------------- doesn't satisfy `_: Lower<_>`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:434:1
    |
434 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `_: Lower<_>`
    |
note: trait bound `Vec<(std::string::String, ast_spanned::PlayerCollection)>: lower::Lower<_>` was not satisfied
   --> front_end/src/lower.rs:10:8
    |
  8 | impl<T, U> Lower<U> for Spanned<T>
    |            --------     ----------
  9 | where
 10 |     T: Lower<U>,
    |        ^^^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `lower`, perhaps you need to implement one of them:
            candidate #1: `lower::Lower`
            candidate #2: `regex_syntax::hir::interval::Interval`
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `lower` exists for reference `&spans::Spanned<Vec<(std::string::String, std::string::String)>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 | #[spanned_ast]
    | ^^^^^^^^^^^^^^ method cannot be called due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 | pub struct Spanned<T> {
    | --------------------- doesn't satisfy `_: Lower<_>`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:434:1
    |
434 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `_: Lower<_>`
    |
note: trait bound `Vec<(std::string::String, std::string::String)>: lower::Lower<_>` was not satisfied
   --> front_end/src/lower.rs:10:8
    |
  8 | impl<T, U> Lower<U> for Spanned<T>
    |            --------     ----------
  9 | where
 10 |     T: Lower<U>,
    |        ^^^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `lower`, perhaps you need to implement one of them:
            candidate #1: `lower::Lower`
            candidate #2: `regex_syntax::hir::interval::Interval`
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `lower` exists for reference `&spans::Spanned<Vec<(std::string::String, std::string::String, ast_spanned::IntExpr)>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 | #[spanned_ast]
    | ^^^^^^^^^^^^^^ method cannot be called due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 | pub struct Spanned<T> {
    | --------------------- doesn't satisfy `_: Lower<_>`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:434:1
    |
434 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `_: Lower<_>`
    |
note: trait bound `Vec<(std::string::String, std::string::String, ast_spanned::IntExpr)>: lower::Lower<_>` was not satisfied
   --> front_end/src/lower.rs:10:8
    |
  8 | impl<T, U> Lower<U> for Spanned<T>
    |            --------     ----------
  9 | where
 10 |     T: Lower<U>,
    |        ^^^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `lower`, perhaps you need to implement one of them:
            candidate #1: `lower::Lower`
            candidate #2: `regex_syntax::hir::interval::Interval`
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `lower` exists for reference `&spans::Spanned<Vec<ast_spanned::FlowComponent>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 | #[spanned_ast]
    | ^^^^^^^^^^^^^^ method cannot be called on `&spans::Spanned<Vec<ast_spanned::FlowComponent>>` due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 | pub struct Spanned<T> {
    | --------------------- doesn't satisfy `_: Lower<_>`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:434:1
    |
434 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<ast_spanned::FlowComponent>: lower::Lower<_>`
    |
note: trait bound `Vec<ast_spanned::FlowComponent>: lower::Lower<_>` was not satisfied
   --> front_end/src/lower.rs:10:8
    |
  8 | impl<T, U> Lower<U> for Spanned<T>
    |            --------     ----------
  9 | where
 10 |     T: Lower<U>,
    |        ^^^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `lower`, perhaps you need to implement one of them:
            candidate #1: `lower::Lower`
            candidate #2: `regex_syntax::hir::interval::Interval`
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `lower` exists for struct `spans::Spanned<Vec<ast_spanned::Case>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 | #[spanned_ast]
    | ^^^^^^^^^^^^^^ method cannot be called on `spans::Spanned<Vec<ast_spanned::Case>>` due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 | pub struct Spanned<T> {
    | --------------------- method `lower` not found for this struct because it doesn't satisfy `_: Lower<_>`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:434:1
    |
434 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<ast_spanned::Case>: lower::Lower<_>`
    |
note: trait bound `Vec<ast_spanned::Case>: lower::Lower<_>` was not satisfied
   --> front_end/src/lower.rs:10:8
    |
  8 | impl<T, U> Lower<U> for Spanned<T>
    |            --------     ----------
  9 | where
 10 |     T: Lower<U>,
    |        ^^^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `lower`, perhaps you need to implement one of them:
            candidate #1: `lower::Lower`
            candidate #2: `regex_syntax::hir::interval::Interval`
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `walk` exists for reference `&spans::Spanned<Box<ast_spanned::CardPosition>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 |   #[spanned_ast]
    |   ^^^^^^^^^^^^^^ method cannot be called on `&spans::Spanned<Box<ast_spanned::CardPosition>>` due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 |   pub struct Spanned<T> {
    |   --------------------- doesn't satisfy `_: Walker`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:231:1
    |
231 | / pub struct Box<
232 | |     T: ?Sized,
233 | |     #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global,
234 | | >(Unique<T>, A);
    | |_- doesn't satisfy `Box<ast_spanned::CardPosition>: walker::Walker`
    |
note: trait bound `Box<ast_spanned::CardPosition>: walker::Walker` was not satisfied
   --> front_end/src/walker.rs:92:8
    |
 90 | impl<T> Walker for Spanned<T>
    |         ------     ----------
 91 | where
 92 |     T: Walker,
    |        ^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
note: `walker::Walker` defines an item `walk`, perhaps you need to implement it
   --> front_end/src/walker.rs:14:1
    |
 14 | pub trait Walker {
    | ^^^^^^^^^^^^^^^^
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `walk` exists for reference `&spans::Spanned<Box<ast_spanned::IntCollection>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 |   #[spanned_ast]
    |   ^^^^^^^^^^^^^^ method cannot be called on `&spans::Spanned<Box<ast_spanned::IntCollection>>` due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 |   pub struct Spanned<T> {
    |   --------------------- doesn't satisfy `_: Walker`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:231:1
    |
231 | / pub struct Box<
232 | |     T: ?Sized,
233 | |     #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global,
234 | | >(Unique<T>, A);
    | |_- doesn't satisfy `Box<ast_spanned::IntCollection>: walker::Walker`
    |
note: trait bound `Box<ast_spanned::IntCollection>: walker::Walker` was not satisfied
   --> front_end/src/walker.rs:92:8
    |
 90 | impl<T> Walker for Spanned<T>
    |         ------     ----------
 91 | where
 92 |     T: Walker,
    |        ^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
note: `walker::Walker` defines an item `walk`, perhaps you need to implement it
   --> front_end/src/walker.rs:14:1
    |
 14 | pub trait Walker {
    | ^^^^^^^^^^^^^^^^
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `walk` exists for reference `&spans::Spanned<Box<ast_spanned::IntExpr>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 |   #[spanned_ast]
    |   ^^^^^^^^^^^^^^ method cannot be called on `&spans::Spanned<Box<ast_spanned::IntExpr>>` due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 |   pub struct Spanned<T> {
    |   --------------------- doesn't satisfy `_: Walker`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:231:1
    |
231 | / pub struct Box<
232 | |     T: ?Sized,
233 | |     #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global,
234 | | >(Unique<T>, A);
    | |_- doesn't satisfy `Box<ast_spanned::IntExpr>: walker::Walker`
    |
note: trait bound `Box<ast_spanned::IntExpr>: walker::Walker` was not satisfied
   --> front_end/src/walker.rs:92:8
    |
 90 | impl<T> Walker for Spanned<T>
    |         ------     ----------
 91 | where
 92 |     T: Walker,
    |        ^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
note: `walker::Walker` defines an item `walk`, perhaps you need to implement it
   --> front_end/src/walker.rs:14:1
    |
 14 | pub trait Walker {
    | ^^^^^^^^^^^^^^^^
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `walk` exists for reference `&spans::Spanned<Box<ast_spanned::CardSet>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 |   #[spanned_ast]
    |   ^^^^^^^^^^^^^^ method cannot be called on `&spans::Spanned<Box<ast_spanned::CardSet>>` due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 |   pub struct Spanned<T> {
    |   --------------------- doesn't satisfy `_: Walker`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:231:1
    |
231 | / pub struct Box<
232 | |     T: ?Sized,
233 | |     #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global,
234 | | >(Unique<T>, A);
    | |_- doesn't satisfy `Box<ast_spanned::CardSet>: walker::Walker`
    |
note: trait bound `Box<ast_spanned::CardSet>: walker::Walker` was not satisfied
   --> front_end/src/walker.rs:92:8
    |
 90 | impl<T> Walker for Spanned<T>
    |         ------     ----------
 91 | where
 92 |     T: Walker,
    |        ^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
note: `walker::Walker` defines an item `walk`, perhaps you need to implement it
   --> front_end/src/walker.rs:14:1
    |
 14 | pub trait Walker {
    | ^^^^^^^^^^^^^^^^
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `walk` exists for reference `&spans::Spanned<Box<ast_spanned::BoolExpr>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 |   #[spanned_ast]
    |   ^^^^^^^^^^^^^^ method cannot be called on `&spans::Spanned<Box<ast_spanned::BoolExpr>>` due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 |   pub struct Spanned<T> {
    |   --------------------- doesn't satisfy `_: Walker`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:231:1
    |
231 | / pub struct Box<
232 | |     T: ?Sized,
233 | |     #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global,
234 | | >(Unique<T>, A);
    | |_- doesn't satisfy `Box<ast_spanned::BoolExpr>: walker::Walker`
    |
note: trait bound `Box<ast_spanned::BoolExpr>: walker::Walker` was not satisfied
   --> front_end/src/walker.rs:92:8
    |
 90 | impl<T> Walker for Spanned<T>
    |         ------     ----------
 91 | where
 92 |     T: Walker,
    |        ^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
note: `walker::Walker` defines an item `walk`, perhaps you need to implement it
   --> front_end/src/walker.rs:14:1
    |
 14 | pub trait Walker {
    | ^^^^^^^^^^^^^^^^
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `walk` exists for reference `&spans::Spanned<Box<ast_spanned::StringExpr>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 |   #[spanned_ast]
    |   ^^^^^^^^^^^^^^ method cannot be called on `&spans::Spanned<Box<ast_spanned::StringExpr>>` due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 |   pub struct Spanned<T> {
    |   --------------------- doesn't satisfy `_: Walker`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:231:1
    |
231 | / pub struct Box<
232 | |     T: ?Sized,
233 | |     #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global,
234 | | >(Unique<T>, A);
    | |_- doesn't satisfy `Box<ast_spanned::StringExpr>: walker::Walker`
    |
note: trait bound `Box<ast_spanned::StringExpr>: walker::Walker` was not satisfied
   --> front_end/src/walker.rs:92:8
    |
 90 | impl<T> Walker for Spanned<T>
    |         ------     ----------
 91 | where
 92 |     T: Walker,
    |        ^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
note: `walker::Walker` defines an item `walk`, perhaps you need to implement it
   --> front_end/src/walker.rs:14:1
    |
 14 | pub trait Walker {
    | ^^^^^^^^^^^^^^^^
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `walk` exists for reference `&spans::Spanned<Box<ast_spanned::FilterExpr>>`, but its trait bounds were not satisfied
   --> front_end/src/ast.rs:3:1
    |
  3 |   #[spanned_ast]
    |   ^^^^^^^^^^^^^^ method cannot be called on `&spans::Spanned<Box<ast_spanned::FilterExpr>>` due to unsatisfied trait bounds
    |
   ::: front_end/src/spans.rs:30:1
    |
 30 |   pub struct Spanned<T> {
    |   --------------------- doesn't satisfy `_: Walker`
    |
   ::: /home/till/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:231:1
    |
231 | / pub struct Box<
232 | |     T: ?Sized,
233 | |     #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global,
234 | | >(Unique<T>, A);
    | |_- doesn't satisfy `Box<ast_spanned::FilterExpr>: walker::Walker`
    |
note: trait bound `Box<ast_spanned::FilterExpr>: walker::Walker` was not satisfied
   --> front_end/src/walker.rs:92:8
    |
 90 | impl<T> Walker for Spanned<T>
    |         ------     ----------
 91 | where
 92 |     T: Walker,
    |        ^^^^^^ unsatisfied trait bound introduced here
    = help: items from traits can only be used if the trait is implemented and in scope
note: `walker::Walker` defines an item `walk`, perhaps you need to implement it
   --> front_end/src/walker.rs:14:1
    |
 14 | pub trait Walker {
    | ^^^^^^^^^^^^^^^^
    = note: this error originates in the attribute macro `spanned_ast` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0609]: no field `node` on type `ast::ast::ChoiceRule`
   --> front_end/src/ir.rs:449:49
    |
449 |             self.build_choice_rule(&choice_rule.node, entry, exit)
    |                                                 ^^^^ unknown field
    |
    = note: available field is: `options`

error[E0609]: no field `node` on type `ast::ast::SeqStage`
   --> front_end/src/ir.rs:452:45
    |
452 |             self.build_seq_stage(&seq_stage.node, entry, exit)
    |                                             ^^^^ unknown field
    |
    = note: available fields are: `stage`, `player`, `end_condition`, `flows`

error[E0609]: no field `node` on type `ast::ast::IfRule`
   --> front_end/src/ir.rs:459:41
    |
459 |             self.build_if_rule(&if_rule.node, entry, exit)
    |                                         ^^^^ unknown field
    |
    = note: available fields are: `condition`, `flows`

error[E0609]: no field `node` on type `ast::ast::OptionalRule`
   --> front_end/src/ir.rs:462:53
    |
462 |             self.build_optional_rule(&optional_rule.node, entry, exit)
    |                                                     ^^^^ unknown field
    |
    = note: available field is: `flows`

error[E0609]: no field `node` on type `ast::ast::Conditional`
   --> front_end/src/ir.rs:465:45
    |
465 |             self.build_cond_rule(&cond_rule.node, entry, exit)
    |                                             ^^^^ unknown field
    |
    = note: available field is: `cases`

error[E0609]: no field `node` on type `ast::ast::EndCondition`
   --> front_end/src/ir.rs:503:25
    |
503 |     match end_condition.node {
    |                         ^^^^ unknown field

error[E0609]: no field `span` on type `ast::ast::ActionRule`
   --> front_end/src/ir.rs:578:63
    |
578 |                   GameFlowError::NoStageToEnd { span: spanned.span.clone() }
    |                                                               ^^^^ unknown field

error[E0609]: no field `node` on type `ast::ast::Case`
   --> front_end/src/ir.rs:659:33
    |
659 |       match &cond_rule.cases[i].node {
    |                                 ^^^^ unknown field

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:155:33
    |
155 |                     self.use_id(&spanned);
    |                          ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                          |
    |                          arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:161:33
    |
161 |                     self.use_id(&spanned);
    |                          ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                          |
    |                          arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:176:37
    |
176 |                         self.use_id(&spanned1);
    |                              ------ ^^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:184:37
    |
184 |                         self.use_id(&spanned);
    |                              ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:193:37
    |
193 |                         self.use_id(&spanned1);
    |                              ------ ^^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:196:37
    |
196 |                         self.use_id(&spanned2);
    |                              ------ ^^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:204:37
    |
204 |                         self.use_id(&spanned);
    |                              ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:212:37
    |
212 |                         self.use_id(&spanned);
    |                              ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:220:37
    |
220 |                         self.use_id(&spanned);
    |                              ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:228:37
    |
228 |                         self.use_id(&spanned);
    |                              ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:231:37
    |
231 |                         self.use_id(&spanned);
    |                              ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:234:37
    |
234 |                         self.use_id(&spanned);
    |                              ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:241:37
    |
241 |                         self.use_id(&spanned2);
    |                              ------ ^^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:244:37
    |
244 |                         self.use_id(&spanned2);
    |                              ------ ^^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:256:37
    |
256 |                         self.use_id(&spanned);
    |                              ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:259:37
    |
259 |                         self.use_id(&spanned);
    |                              ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:267:37
    |
267 |                         self.use_id(&spanned);
    |                              ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:270:37
    |
270 |                         self.use_id(&spanned);
    |                              ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:273:37
    |
273 |                         self.use_id(&spanned);
    |                              ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:274:37
    |
274 |                         self.use_id(&spanned1);
    |                              ------ ^^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:277:37
    |
277 |                         self.use_id(&spanned);
    |                              ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:278:37
    |
278 |                         self.use_id(&spanned1);
    |                              ------ ^^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:281:37
    |
281 |                         self.use_id(&spanned);
    |                              ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:282:37
    |
282 |                         self.use_id(&spanned1);
    |                              ------ ^^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:285:37
    |
285 |                         self.use_id(&spanned);
    |                              ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:288:37
    |
288 |                         self.use_id(&spanned);
    |                              ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:291:37
    |
291 |                         self.use_id(&spanned);
    |                              ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:300:42
    |
300 | ...                   self.init_id(s, GameType::Player);
    |                            ------- ^ expected `&Spanned<String>`, found `&String`
    |                            |
    |                            arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:48:8
    |
 48 |     fn init_id(&mut self, id: &SID, game_type: GameType) {
    |        ^^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:305:42
    |
305 | ...                   self.init_id(t, GameType::Team);
    |                            ------- ^ expected `&Spanned<String>`, found `&String`
    |                            |
    |                            arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:48:8
    |
 48 |     fn init_id(&mut self, id: &SID, game_type: GameType) {
    |        ^^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:310:42
    |
310 | ...                   self.init_id(s, GameType::Location);
    |                            ------- ^ expected `&Spanned<String>`, found `&String`
    |                            |
    |                            arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:48:8
    |
 48 |     fn init_id(&mut self, id: &SID, game_type: GameType) {
    |        ^^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:314:37
    |
314 |                         self.use_id(&spanned);
    |                              ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:317:38
    |
317 |                         self.init_id(&spanned1, GameType::Token);
    |                              ------- ^^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:48:8
    |
 48 |     fn init_id(&mut self, id: &SID, game_type: GameType) {
    |        ^^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:318:37
    |
318 |                         self.use_id(&spanned2);
    |                              ------ ^^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:321:38
    |
321 |                         self.init_id(&spanned, GameType::Combo);
    |                              ------- ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:48:8
    |
 48 |     fn init_id(&mut self, id: &SID, game_type: GameType) {
    |        ^^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:324:38
    |
324 |                         self.init_id(&spanned, GameType::Memory);
    |                              ------- ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:48:8
    |
 48 |     fn init_id(&mut self, id: &SID, game_type: GameType) {
    |        ^^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:327:38
    |
327 |                         self.init_id(&spanned, GameType::Memory);
    |                              ------- ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:48:8
    |
 48 |     fn init_id(&mut self, id: &SID, game_type: GameType) {
    |        ^^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:330:38
    |
330 |                         self.init_id(&spanned, GameType::Precedence);
    |                              ------- ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:48:8
    |
 48 |     fn init_id(&mut self, id: &SID, game_type: GameType) {
    |        ^^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:332:41
    |
332 | ...                   self.use_id(k);
    |                            ------ ^ expected `&Spanned<String>`, found `&String`
    |                            |
    |                            arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:333:41
    |
333 | ...                   self.use_id(v);
    |                            ------ ^ expected `&Spanned<String>`, found `&String`
    |                            |
    |                            arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:337:38
    |
337 |                         self.init_id(&spanned, GameType::PointMap);
    |                              ------- ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:48:8
    |
 48 |     fn init_id(&mut self, id: &SID, game_type: GameType) {
    |        ^^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:339:41
    |
339 | ...                   self.use_id(k);
    |                            ------ ^ expected `&Spanned<String>`, found `&String`
    |                            |
    |                            arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:340:41
    |
340 | ...                   self.use_id(v);
    |                            ------ ^ expected `&Spanned<String>`, found `&String`
    |                            |
    |                            arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:349:37
    |
349 |                         self.use_id(&spanned);
    |                              ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:352:37
    |
352 |                         self.use_id(&spanned);
    |                              ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:355:37
    |
355 |                         self.use_id(&spanned);
    |                              ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:366:37
    |
366 |                         self.use_id(&spanned);
    |                              ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:369:37
    |
369 |                         self.use_id(&spanned1);
    |                              ------ ^^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:376:37
    |
376 |                         self.use_id(&spanned1);
    |                              ------ ^^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0308]: mismatched types
   --> front_end/src/symbols.rs:384:37
    |
384 |                         self.use_id(&spanned);
    |                              ------ ^^^^^^^^ expected `&Spanned<String>`, found `&String`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected reference `&spans::Spanned<std::string::String>`
               found reference `&std::string::String`
note: method defined here
   --> front_end/src/symbols.rs:44:8
    |
 44 |     fn use_id(&mut self, id: &SID) {
    |        ^^^^^^            --------

error[E0609]: no field `node` on type `std::string::String`
  --> front_end/src/semantic.rs:91:40
   |
91 |                       node: precedence.node.clone() 
   |                                        ^^^^ unknown field

error[E0609]: no field `node` on type `&std::string::String`
  --> front_end/src/semantic.rs:93:24
   |
93 |                     (k.node.clone(), precedence.span.clone())
   |                        ^^^^ unknown field

error[E0609]: no field `span` on type `std::string::String`
  --> front_end/src/semantic.rs:93:49
   |
93 |                     (k.node.clone(), precedence.span.clone())
   |                                                 ^^^^ unknown field

error[E0609]: no field `node` on type `&std::string::String`
  --> front_end/src/semantic.rs:97:63
   |
97 |                       ty: CorrespondanceType::Value { node: v.node.clone() }, 
   |                                                               ^^^^ unknown field

error[E0609]: no field `node` on type `&std::string::String`
  --> front_end/src/semantic.rs:98:30
   |
98 |                       key: k.node.clone(), 
   |                              ^^^^ unknown field

error[E0609]: no field `span` on type `&std::string::String`
  --> front_end/src/semantic.rs:99:31
   |
99 |                       span: v.span.clone() 
   |                               ^^^^ unknown field

error[E0609]: no field `node` on type `std::string::String`
   --> front_end/src/semantic.rs:108:38
    |
108 |                       node: pointmap.node.clone() 
    |                                      ^^^^ unknown field

error[E0609]: no field `node` on type `&std::string::String`
   --> front_end/src/semantic.rs:110:24
    |
110 |                     (k.node.clone(), pointmap.span.clone())
    |                        ^^^^ unknown field

error[E0609]: no field `span` on type `std::string::String`
   --> front_end/src/semantic.rs:110:47
    |
110 |                     (k.node.clone(), pointmap.span.clone())
    |                                               ^^^^ unknown field

error[E0609]: no field `node` on type `&std::string::String`
   --> front_end/src/semantic.rs:114:63
    |
114 |                       ty: CorrespondanceType::Value { node: v.node.clone() }, 
    |                                                               ^^^^ unknown field

error[E0609]: no field `node` on type `&std::string::String`
   --> front_end/src/semantic.rs:115:30
    |
115 |                       key: k.node.clone(), 
    |                              ^^^^ unknown field

error[E0609]: no field `span` on type `&std::string::String`
   --> front_end/src/semantic.rs:116:31
    |
116 |                       span: v.span.clone() 
    |                               ^^^^ unknown field

error[E0609]: no field `node` on type `ast::ast::Types`
   --> front_end/src/semantic.rs:122:38
    |
122 |                 for (k, vs) in types.node.types.iter() {
    |                                      ^^^^ unknown field
    |
    = note: available field is: `types`

error[E0609]: no field `node` on type `std::string::String`
   --> front_end/src/semantic.rs:141:77
    |
141 |                       ty: CorrespondanceType::Precedence { node: precedence.node.clone() }, 
    |                                                                             ^^^^ unknown field

error[E0609]: no field `node` on type `std::string::String`
   --> front_end/src/semantic.rs:142:32
    |
142 |                       key: key.node.clone(), 
    |                                ^^^^ unknown field

error[E0609]: no field `span` on type `std::string::String`
   --> front_end/src/semantic.rs:143:40
    |
143 |                       span: precedence.span.clone() 
    |                                        ^^^^ unknown field

error[E0609]: no field `node` on type `std::string::String`
   --> front_end/src/semantic.rs:150:77
    |
150 |                       ty: CorrespondanceType::Precedence { node: precedence.node.clone() }, 
    |                                                                             ^^^^ unknown field

error[E0609]: no field `node` on type `std::string::String`
   --> front_end/src/semantic.rs:151:32
    |
151 |                       key: key.node.clone(), 
    |                                ^^^^ unknown field

error[E0609]: no field `span` on type `std::string::String`
   --> front_end/src/semantic.rs:152:40
    |
152 |                       span: precedence.span.clone() 
    |                                        ^^^^ unknown field

error[E0609]: no field `node` on type `std::string::String`
   --> front_end/src/semantic.rs:159:77
    |
159 |                       ty: CorrespondanceType::Precedence { node: precedence.node.clone() }, 
    |                                                                             ^^^^ unknown field

error[E0609]: no field `node` on type `std::string::String`
   --> front_end/src/semantic.rs:160:32
    |
160 |                       key: key.node.clone(), 
    |                                ^^^^ unknown field

error[E0609]: no field `span` on type `std::string::String`
   --> front_end/src/semantic.rs:161:40
    |
161 |                       span: precedence.span.clone() 
    |                                        ^^^^ unknown field

error[E0609]: no field `node` on type `Box<ast::ast::StringExpr>`
   --> front_end/src/semantic.rs:166:33
    |
166 |                   match &string.node {
    |                                 ^^^^ unknown field

error[E0609]: no field `node` on type `ast::ast::QueryString`
   --> front_end/src/semantic.rs:168:32
    |
168 |                       match &q.node {
    |                                ^^^^ unknown field

error[E0609]: no field `node` on type `std::string::String`
   --> front_end/src/semantic.rs:172:41
    |
172 | ...                   node: k.node.clone() 
    |                               ^^^^ unknown field

error[E0609]: no field `node` on type `std::string::String`
   --> front_end/src/semantic.rs:174:32
    |
174 | ...                   (k.node.clone(), k.span.clone())
    |                          ^^^^ unknown field

error[E0609]: no field `span` on type `std::string::String`
   --> front_end/src/semantic.rs:174:48
    |
174 | ...                   (k.node.clone(), k.span.clone())
    |                                          ^^^^ unknown field

error[E0609]: no field `node` on type `std::string::String`
   --> front_end/src/semantic.rs:178:69
    |
178 | ...                   ty: CorrespondanceType::Key { node: k.node.clone() }, 
    |                                                             ^^^^ unknown field

error[E0609]: no field `node` on type `std::string::String`
   --> front_end/src/semantic.rs:179:40
    |
179 | ...                   key: key.node.clone(), 
    |                                ^^^^ unknown field

error[E0609]: no field `span` on type `std::string::String`
   --> front_end/src/semantic.rs:180:39
    |
180 | ...                   span: k.span.clone() 
    |                               ^^^^ unknown field

error[E0609]: no field `node` on type `std::string::String`
   --> front_end/src/semantic.rs:190:71
    |
190 |                           ty: CorrespondanceType::Value { node: value.node.clone() }, 
    |                                                                       ^^^^ unknown field

error[E0609]: no field `node` on type `std::string::String`
   --> front_end/src/semantic.rs:191:36
    |
191 |                           key: key.node.clone(), 
    |                                    ^^^^ unknown field

error[E0609]: no field `span` on type `std::string::String`
   --> front_end/src/semantic.rs:192:39
    |
192 |                           span: value.span.clone() 
    |                                       ^^^^ unknown field

Some errors have detailed explanations: E0308, E0432, E0599, E0609.
For more information about an error, try `rustc --explain E0308`.
error: could not compile `front_end` (lib) due to 137 previous errors
